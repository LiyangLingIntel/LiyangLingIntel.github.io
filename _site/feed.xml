<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leon Ling's Blog</title>
    <description>孤独是人生的常态吗？</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 05 Dec 2019 10:51:45 +0800</pubDate>
    <lastBuildDate>Thu, 05 Dec 2019 10:51:45 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Leon Ling's Blog 重启说明</title>
        <description>&lt;p&gt;沉寂了秋招的两个多月, 终于再次重新启动了个人博客的项目😅, 又可以开始学习了呢🙃.&lt;/p&gt;

&lt;p&gt;这次重启, 相比旧的版本, 首先纠正了以前posts因为tag格式不够规范引起的&lt;code class=&quot;highlighter-rouge&quot;&gt;YML&lt;/code&gt;文件头丢失的BUG, 然后参考其他优秀的博客框架, 对原来的博客框架做出了一些调整和优化, 也引入了一些新的功能, 大概如下.&lt;/p&gt;

&lt;h3 id=&quot;1-新功能引入&quot;&gt;1. 新功能引入&lt;/h3&gt;

&lt;p&gt;在茫茫多的 &lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;Jekyll 主题&lt;/a&gt;中我挑中了 &lt;a href=&quot;https://github.com/kitian616&quot;&gt;kitian616&lt;/a&gt; 的 [&lt;a href=&quot;https://tianqi.name/jekyll-TeXt-theme/&quot;&gt;&lt;strong&gt;TeXt&lt;/strong&gt;&lt;/a&gt;] 和 &lt;a href=&quot;&quot;&gt;Huangxuan&lt;/a&gt; 的 [&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io&quot;&gt;&lt;strong&gt;HuxPro&lt;/strong&gt;&lt;/a&gt;]. 原因很简单, 这两款主题风格都非常简单好看, 然后对 Markdown 语法和内嵌 LaTeX 支持良好, 然后也有一些细节上的特性和小功能非常有趣.&lt;/p&gt;

&lt;p&gt;最终, 因为更熟悉中意 &lt;strong&gt;HuxPro&lt;/strong&gt; 的风格, 这里基于 Hux 提供的 Boilerplate 进行了一次简单的二次定制, 加入了一些 TeXt 上看到的小功能.&lt;/p&gt;

&lt;h4 id=&quot;post-分享功能&quot;&gt;Post 分享功能&lt;/h4&gt;

&lt;p&gt;首先是引入了&lt;strong&gt;TeXt&lt;/strong&gt;主题中使用的分享功能 – &lt;a href=&quot;https://www.addthis.com/&quot;&gt;&lt;strong&gt;AddThis&lt;/strong&gt;&lt;/a&gt;. 现在每篇Post都可以通过右下角的小图标做快捷分享.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/in-post/2019-11-26-Blog-重启声明/2019-11-28_18-49-44.gif&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;站内搜索&quot;&gt;站内搜索&lt;/h4&gt;

&lt;p&gt;然后, 相比&lt;strong&gt;TeXt&lt;/strong&gt;和&lt;strong&gt;JeKyll&lt;/strong&gt;的主流主题&lt;strong&gt;Next&lt;/strong&gt;, &lt;strong&gt;HuxPro&lt;/strong&gt;的一个小缺陷是没有站内搜索功能, 当以后Post比较多的时候, 只通过Tag分类来查找的方法就显得有点不够效率.&lt;/p&gt;

&lt;p&gt;因此, 这里我通过 &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search&quot;&gt;&lt;strong&gt;Simple-Jekyll-Search&lt;/strong&gt;&lt;/a&gt; 模块, 实现了一个简单的在侧边栏的站内模糊搜索.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/in-post/2019-11-26-Blog-重启声明/2019-11-28_19-24-15.gif&quot; width=&quot;250&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-旧版细节优化&quot;&gt;2. 旧版细节优化&lt;/h3&gt;

&lt;p&gt;因为之前是参考基于 HuxPro 搭建的 &lt;a href=&quot;https://github.com/qiubaiying/qiubaiying.github.io&quot;&gt;BY Blog&lt;/a&gt;, 然后自己也添加了点不成熟的修改, 最终导致出现一些小问题没有解决.&lt;/p&gt;

&lt;h4 id=&quot;代码块高亮&quot;&gt;代码块高亮&lt;/h4&gt;

&lt;p&gt;之前的版本中, 代码块只能以 plain text 显示, 无法根据对应语言自动高亮. 现在修复了这个Bug. 未来还有想法实现对多种代码高亮风格的支持. (目前这样黑色也挺好看的, 不是我懒~&lt;/p&gt;

&lt;h4 id=&quot;archive-界面的优化&quot;&gt;Archive 界面的优化&lt;/h4&gt;

&lt;p&gt;之前是通过页面的锚去做直接滚动, 新版本则是直接去做异步跳转. 使用起来应该会更方便一些. 
直接看效果图.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Old Version:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/in-post/2019-11-26-Blog-重启声明/2019-11-28_19-51-40.gif&quot; alt=&quot;2019-11-28_19-51-40&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;New Version:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/in-post/2019-11-26-Blog-重启声明/2019-11-28_19-53-30.gif&quot; alt=&quot;2019-11-28_19-53-30&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-post-tag-设计规则&quot;&gt;3. Post Tag 设计规则&lt;/h3&gt;

&lt;p&gt;本身我搭建这个博客的目的就是一方面鼓励自己坚持学习, 另一方面通过博客框架的自动标签功能实现快速多分类, 以便于知识内容的管理和快速回顾. 但是使用几个月之后发现, 当post变多之后, 之前草率定下的标签就会出现冗余和混乱.&lt;/p&gt;

&lt;p&gt;因此在新的版本, 我制定了一个标签设定规则并且重新整理了过去所有post的标签. 具体规则我会在 &lt;a href=&quot;https://lyonling.github.io/about/&quot;&gt;&lt;strong&gt;About&lt;/strong&gt;&lt;/a&gt; 保持更新, 内容如下:&lt;/p&gt;

&lt;p&gt;根据post所属领域和相关内容, tag以多级形式排列. 其中第0级属于标签分类, 不做实际用途.
此外, 所有标签以驼峰法命名, 当post中提到低级tag时, 其对应的父级tag也需要在前面提到.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-pseudocode&quot;&gt;- 编程语言
  - Python
  - C++
  - Java
  - JavaScript
  - Shell
  - MarkDown
- 计算机基础
  - OperatingSystem
    - Mac
    - Linux
    - Windows
  - ComputerNetworks
  - Database
  - Algorithm
- 大数据 &amp;amp; 数据科学
  - Maths
  - MachineLearning
  - SocialNetworks
  - NLP
  - DataMining
  - BigData
	  - Spark
- 工具 &amp;amp; 框架
  - Github
  - Hive
  - BlockChain
- 抽象类别
  - Foundation
  - Tutorial
  - Tricks				# 小技巧
  - Anouncement		# Blog的一些公告
  - Debug					# 写程序时遇到的坑&amp;amp;Debug的经验
  - Experience		# 一些形如面经这类的经验内容
  - Notes					# 读书笔记
  - 医疗常识
  - 转载
- 企业相关
	- Alibaba
- 专栏						# 读书笔记, 系统性主题复习等等
  - 百面机器学习
  - 谷歌方法论			# 吴军老师的 谷歌方法论 &amp;amp; 硅谷来信 系列内容阅读笔记
	- JobHunting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在post里, 高级别的tag应该置于低级别的tag之前, 一篇post中的tag数量最好不要超过5个 (多了容易出现丢失YML头的BUG, 暂时不知道为啥…).&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/26/Blog-%E9%87%8D%E5%90%AF%E5%A3%B0%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/26/Blog-%E9%87%8D%E5%90%AF%E5%A3%B0%E6%98%8E/</guid>
        
        <category>Anouncement</category>
        
        
      </item>
    
      <item>
        <title>博客迁移说明</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“ 🙉🙉🙉 ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;万万没想到, 本来准备好好经营的博客也有迁移的一天.&lt;/p&gt;

&lt;p&gt;本来维护这样一个博客, 一方面是记录自己的学习历程, 另一方面也是利用博客系统的tag功能给自己的笔记做个分类.&lt;/p&gt;

&lt;p&gt;现在看来这种笔记分类方法还是效果不够好, 而且博客框架本身似乎也存在一些Bug, 最近忙着秋招也没有时间去调试.&lt;/p&gt;

&lt;p&gt;因此, 我把所有的笔记和学习记录重新整理, 更加系统地迁移到了&lt;strong&gt;Notion&lt;/strong&gt;平台上. 欢迎大家访问 &lt;a href=&quot;https://www.notion.so/leonling/&quot;&gt;&lt;strong&gt;👉我的Notion Workspace👈&lt;/strong&gt;&lt;/a&gt;和发表看法, 如果存在权限问题请直接给我邮件(&lt;a href=&quot;mailto:leon.ling@connect.ust.hk&quot;&gt;leon.ling@connect.ust.hk&lt;/a&gt;)或者在本帖下留言留下邮箱, 我这边手动开放权限. 后续我也会逐步开放整个notion workspace的访问权限(当前可能只有部分已经整理完成的Page).&lt;/p&gt;

&lt;p&gt;或许等工作和生活环境确定下来了, 我会抽时间再重新启动博客项目, 明天再见.&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/09/10/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AF%B4%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/10/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AF%B4%E6%98%8E/</guid>
        
        
      </item>
    
      <item>
        <title>C++ std中vector和list的区别</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3 id=&quot;1-数据结构设计&quot;&gt;1. 数据结构设计&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;vector数据结构&lt;/p&gt;

    &lt;p&gt;vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
因此能高效的进行随机存取，时间复杂度为o(1);
但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;list数据结构&lt;/p&gt;

    &lt;p&gt;list是由双向链表实现的，因此内存空间是不连续的。
只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
但由于链表的特点，能高效地进行插入和删除。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-区别和联系&quot;&gt;2. 区别和联系&lt;/h3&gt;

&lt;p&gt;用一个简单的vector和list使用示例说明：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;list&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;////往v和l中分别添加元素&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;v[2]=&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//cout&amp;lt;&amp;lt;&quot;l[2]=&quot;&amp;lt;&amp;lt;l[2]&amp;lt;&amp;lt;endl;  			//编译错误,list没有重载[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;//cout&amp;lt;&amp;lt;(l.begin()&amp;lt;l.end())&amp;lt;&amp;lt;endl; 	/编译错误,list::iterator没有重载&amp;lt;或&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//cout&amp;lt;&amp;lt;*(l.begin()+1)&amp;lt;&amp;lt;endl; 			//编译错误,list::iterator没有重载+&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;itv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//itl=itl+2; 												//编译错误,list::iterator没有重载+&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;itl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 															&lt;span class=&quot;c1&quot;&gt;//list::iterator中重载了++，只能使用++进行迭代访问。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;itl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;getchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vector拥有一段连续的内存空间，能很好的支持随机存取，
因此&lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;int&amp;gt;::iterator&lt;/code&gt;支持“+”，“+=”，“&amp;lt;”等操作符。&lt;/p&gt;

&lt;p&gt;list的内存空间可以是不连续，它不支持随机访问，
因此&lt;code class=&quot;highlighter-rouge&quot;&gt;list&amp;lt;int&amp;gt;::iterator&lt;/code&gt;则不支持“+”、“+=”、“&amp;lt;”等&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;int&amp;gt;::iterator&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;list&amp;lt;int&amp;gt;::iterator&lt;/code&gt;都重载了“++”运算符。&lt;/p&gt;

&lt;h3 id=&quot;3-总结&quot;&gt;3. 总结&lt;/h3&gt;

&lt;p&gt;如果需要&lt;u&gt;高效的随机存取&lt;/u&gt;，而不在乎插入和删除的效率，使用vector;
如果需要&lt;u&gt;大量的插入和删除&lt;/u&gt;，而不关心随机存取，则应使用list。&lt;/p&gt;
</description>
        <pubDate>Sat, 31 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/31/C++%E4%B8%AD%E7%9A%84vector%E5%92%8Clist/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/31/C++%E4%B8%AD%E7%9A%84vector%E5%92%8Clist/</guid>
        
        <category>C++</category>
        
        <category>Programming</category>
        
        <category>Foundations</category>
        
        
      </item>
    
      <item>
        <title>Spark编程优化经验</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在PA用spark去完成业务的过程中有各种各样的问题, 也有查阅各种资料, 这边结合已有的资源积累写一个spark程序的经验记录.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3 id=&quot;1-一个sparkcontext里进行的action不应该有太多&quot;&gt;1. 一个SparkContext里进行的action不应该有太多&lt;/h3&gt;

&lt;p&gt;一个 SparkContext 对应一个 spark 应用程序, 在程序里会有很多的 rdd transformation 操作和 action 操作, 一个 action 操作划分为一个 job. 一个job的执行, 会在worker端的内存里存放很多task相关的信息, 而这些task的信息只会在 sparkContext 结束时才会清理, 所以如果 action操作太多, 那么前面历史job积累的大量task信息会占用大量的内存空间, 导致后面的task分配空间时会棉铃大量的GC, 从而浪费计算时间.&lt;/p&gt;

&lt;p&gt;解决办法: 将过多的action拆分到几个 sparkContext中同时进行.&lt;/p&gt;

&lt;h3 id=&quot;2-rdd计算任务的并行度不够高&quot;&gt;2. RDD计算任务的并行度不够高&lt;/h3&gt;

&lt;p&gt;RDD计算任务的并行度大致分为两种: 一种是初始RDD任务的并发度, 一种是shuffle后的RDD任务并发度.&lt;/p&gt;

&lt;p&gt;如果是初始RDD任务的并发度不高, 可以通过命令提高partition的数量.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repartition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# num 通常取值 2*CPU ~ 1000
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是shuffle后的RDD任务并发度不够高,可以在每个shuffle操作函数传入一个num值, 如&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reduceByKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numTasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distinct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numTasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-在shuffle之前过滤无效数据&quot;&gt;3. 在shuffle之前过滤无效数据&lt;/h3&gt;

&lt;p&gt;数据在spark计算的stage链上以pipeline的形式流动, 对于无效的数据必须在shuffle操作之前进行过滤, 过滤的方式是使用RDD的filter操作.&lt;/p&gt;

&lt;h3 id=&quot;4-被处理的数据最小单元不要有空行或者null值&quot;&gt;4. 被处理的数据最小单元不要有空行或者NULL值&lt;/h3&gt;

&lt;p&gt;在spark计算任务中, pipeline形式流动的最小数据单元不要有空行或者NULL值, 因为这样会导致某些计算任务出现未知的作物. 对空行和控制要在进行计算前进行filter处理. 在某个计算任务中捕获异常后需要向后继续传递数据时, 可以传递一些自定义的无意义不影响计算结果的数据.&lt;/p&gt;

&lt;h3 id=&quot;5-reduceby-操作替代-groupby&quot;&gt;5. reduceBy 操作替代 groupBy&lt;/h3&gt;

&lt;p&gt;在数据量比较大的情况下, groupBy 总会在shuffle的时候消耗掉大量的时间.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/739727/201801/739727-20180126174937069-1579617042.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/739727/201801/739727-20180126175121959-313725154.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示, reduceBy 操作在数据shuffle之前会将每个partition的数据进行一次聚合, 这样数据量大大减少, 而 groupBy则没有这种操作, shuffle的时候就会有大量数据在计算网络上进行传输.&lt;/p&gt;

&lt;h3 id=&quot;6-关于join的优化&quot;&gt;6. 关于join的优化&lt;/h3&gt;

&lt;h3 id=&quot;7-尽量避免在rdd上执行collect操作&quot;&gt;7. 尽量避免在RDD上执行collect操作&lt;/h3&gt;

&lt;p&gt;在RDD上执行collect操作一般目的是为了将woker端的计算结果收集到dirver端. 如果结果的数据量特别大, 那么就容易导致driver端的OOM问题. 同时集群上的网络传输也会非常耗时.&lt;/p&gt;

&lt;p&gt;一般的解决方案就是先把结果保存到HDFS上, 然后再从HDFS读取数据.&lt;/p&gt;

&lt;h3 id=&quot;8-经常使用的中间rdd-对这个rdd进行cache操作&quot;&gt;8. 经常使用的中间RDD, 对这个RDD进行cache操作&lt;/h3&gt;

&lt;p&gt;这里有几个关键的知识点.&lt;/p&gt;

&lt;p&gt;RDD是 resilient distributed dataset, 是spark数据操作的最基本单位. RDD本身是不可变的, 通过transformation定义RDD的计算图, 因为lazy computation机制, 不会及时触发操作, 然后在每次执行action操作时, 生成新的RDD.&lt;/p&gt;

&lt;p&gt;也是因为lazy computation, 每次执行action操作时, 都会将对应RDD的计算图完整执行一遍, 这样就会带来不必要的重复计算. 通过在action操作前指定cache RDD, 就可以把下次action操作的结果缓存到内存中, 下次计算就从缓存的位置继续开始, 提高计算效率.&lt;/p&gt;

&lt;h3 id=&quot;9-尽量减少transformation和action中的shuffle操作&quot;&gt;9. 尽量减少transformation和action中的shuffle操作&lt;/h3&gt;

&lt;p&gt;Spark Internal中为了提高运行效率, 在每次shuffle操作之后会自动执行一次cache操作, 当cache多了之后就会占用大量内存, 造成较多的GC上的开销.&lt;/p&gt;

&lt;p&gt;对于需要多词shuffle的RDD, 可以在RDD生成之后进行一次partition操作(使用的partitioner和shuffle的一样), 这样这个RDD在后续的shuffle中不会再进行shuffle而做网络传输了.&lt;/p&gt;

&lt;h3 id=&quot;10-spark-long-run-application-需要设置-sparkcleanerttl参数&quot;&gt;10. Spark Long Run Application 需要设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;spark.cleaner.ttl&lt;/code&gt;参数&lt;/h3&gt;

&lt;p&gt;对long run application, 为其分配的内存空间会由于历史task信息的不断累积而减少, 对于后面的计算任务, 进行计算前都需要大量的GC, 十分耗时.&lt;/p&gt;

&lt;p&gt;设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;spark.cleaner.ttl&lt;/code&gt;参数后, spark程序会定时清除历史的task信息.&lt;/p&gt;

</description>
        <pubDate>Fri, 23 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/23/Spark%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/23/Spark%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</guid>
        
        <category>Tutorial</category>
        
        <category>BigData</category>
        
        <category>Spark</category>
        
        
      </item>
    
      <item>
        <title>剑指Offer-数据库&amp;SQL</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;数据库基础&quot;&gt;&lt;strong&gt;数据库基础&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1-事务&quot;&gt;1. 事务&lt;/h3&gt;

&lt;p&gt;事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f74144be-857a-40cd-8ec7-87626ef4e20b.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;11-acid&quot;&gt;1.1 ACID&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;原子性（Atomicity）&lt;/p&gt;

    &lt;p&gt;事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。&lt;/p&gt;

    &lt;p&gt;回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一致性（Consistency）&lt;/p&gt;

    &lt;p&gt;数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;隔离性（Isolation）&lt;/p&gt;

    &lt;p&gt;一个事务所做的修改在最终提交以前，对其它事务是不可见的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;持久性（Durability）&lt;/p&gt;

    &lt;p&gt;一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。&lt;/p&gt;

    &lt;p&gt;使用重做日志来保证持久性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有满足一致性，事务的执行结果才是正确的。&lt;/li&gt;
  &lt;li&gt;在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。&lt;/li&gt;
  &lt;li&gt;在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。&lt;/li&gt;
  &lt;li&gt;事务满足持久化是为了能应对数据库崩溃的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/417bc315-4409-48c6-83e0-59e8d405429e.jpg&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;12-autocommit&quot;&gt;1.2 AUTOCOMMIT&lt;/h4&gt;

&lt;p&gt;MySQL 默认采用自动提交模式。也就是说，如果不显式使用&lt;code class=&quot;highlighter-rouge&quot;&gt;START TRANSACTION&lt;/code&gt;语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。&lt;/p&gt;

&lt;h3 id=&quot;2-并发一致性问题&quot;&gt;2. 并发一致性问题&lt;/h3&gt;

&lt;p&gt;在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。&lt;/p&gt;

&lt;h4 id=&quot;21-丢失修改&quot;&gt;2.1 丢失修改&lt;/h4&gt;

&lt;p&gt;T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/75184b58-c627-4edc-8dcf-605762ebb733.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;22-读脏数据&quot;&gt;2.2 读脏数据&lt;/h4&gt;

&lt;p&gt;T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af0e94d9-502d-4531-938f-d46dd29de52d.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;23-不可重复读&quot;&gt;2.3 不可重复读&lt;/h4&gt;

&lt;p&gt;T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66ae164c-ad47-4905-895e-51fe38ce797a.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;24-幻影读&quot;&gt;2.4 幻影读&lt;/h4&gt;

&lt;p&gt;T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8fdc577d-552d-4b43-b5e4-a8f98bc2cb51.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。&lt;/p&gt;

&lt;h3 id=&quot;3-封锁---通过锁保证事务隔离性&quot;&gt;3. 封锁 - 通过锁保证事务隔离性&lt;/h3&gt;

&lt;h4 id=&quot;31-封锁粒度&quot;&gt;3.1 封锁粒度&lt;/h4&gt;

&lt;p&gt;MySQL 中提供了两种封锁粒度：&lt;strong&gt;行级锁&lt;/strong&gt;以及&lt;strong&gt;表级锁&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的&lt;u&gt;并发程度&lt;/u&gt;就越高。&lt;/p&gt;

&lt;p&gt;但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。&lt;/p&gt;

&lt;p&gt;在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。&lt;/p&gt;

&lt;h4 id=&quot;32-封锁类型&quot;&gt;3.2 封锁类型&lt;/h4&gt;

&lt;h5 id=&quot;1-读写锁&quot;&gt;1. 读写锁&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;排它锁（Exclusive），简写为 X 锁，又称写锁。&lt;/li&gt;
  &lt;li&gt;共享锁（Shared），简写为 S 锁，又称读锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有以下两个规定：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。&lt;/li&gt;
  &lt;li&gt;一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;锁的兼容关系如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;-&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;X&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;2-意向锁&quot;&gt;2. 意向锁&lt;/h5&gt;

&lt;p&gt;使用&lt;strong&gt;意向锁&lt;/strong&gt;（Intention Locks）可以更容易地支持多粒度封锁。&lt;/p&gt;

&lt;p&gt;在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。&lt;/p&gt;

&lt;p&gt;意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；&lt;/li&gt;
  &lt;li&gt;一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。&lt;/p&gt;

&lt;p&gt;各种锁的兼容关系如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;-&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;X&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;IX&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;IS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;解释如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；&lt;/li&gt;
  &lt;li&gt;S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;33-封锁协议&quot;&gt;3.3 封锁协议&lt;/h4&gt;

&lt;h5 id=&quot;1-三级锁协议&quot;&gt;1. 三级锁协议&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;一级封锁协议&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。&lt;/p&gt;

    &lt;p&gt;可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;T1&lt;/th&gt;
      &lt;th&gt;T2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lock-x(A)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read A=20&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;lock-x(A)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;wait&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;write A=19&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;commit&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;unlock-x(A)&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;obtain&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;read A=19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;write A=21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;commit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;unlock-x(A2)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;二级封锁协议&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。&lt;/p&gt;

    &lt;p&gt;可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;T1&lt;/th&gt;
      &lt;th&gt;T2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lock-x(A)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read A=20&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;write A=19&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;lock-s(A)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;wait&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rollback&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A=20&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;unlock-x(A)&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;obtain&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;read A=20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;unlock-s(A)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;commit&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;三级封锁协议&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。&lt;/p&gt;

    &lt;p&gt;可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;T1&lt;/th&gt;
      &lt;th&gt;T2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lock-s(A)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read A=20&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;lock-x(A)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;wait&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read A=20&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;commit&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;unlock-s(A)&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;obtain&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;read A=20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;write A=19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;commit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;unlock-X(A)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;2-两段锁协议&quot;&gt;2. 两段锁协议&lt;/h5&gt;

&lt;p&gt;加锁和解锁分为两个阶段进行。&lt;/p&gt;

&lt;p&gt;可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。&lt;/p&gt;

&lt;p&gt;事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;34-mysql-隐式与显示锁定&quot;&gt;3.4 MySQL 隐式与显示锁定&lt;/h4&gt;

&lt;p&gt;MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。&lt;/p&gt;

&lt;p&gt;InnoDB 也可以使用特定的语句进行显示锁定：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SHARE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MODE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-隔离级别&quot;&gt;4. 隔离级别&lt;/h3&gt;

&lt;h4 id=&quot;41-未提交读read-uncommitted&quot;&gt;4.1 未提交读（READ UNCOMMITTED）&lt;/h4&gt;

&lt;p&gt;事务中的修改，即使没有提交，对其它事务也是可见的。&lt;/p&gt;

&lt;h4 id=&quot;42-提交读read-committed&quot;&gt;4.2 提交读（READ COMMITTED）&lt;/h4&gt;

&lt;p&gt;一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。&lt;/p&gt;

&lt;h4 id=&quot;43-可重复读repeatable-read&quot;&gt;4.3 可重复读（REPEATABLE READ）&lt;/h4&gt;

&lt;p&gt;保证在同一个事务中多次读取同样数据的结果是一样的。&lt;/p&gt;

&lt;h4 id=&quot;44-可串行化serializable&quot;&gt;4.4 可串行化（SERIALIZABLE）&lt;/h4&gt;

&lt;p&gt;强制事务串行执行。&lt;/p&gt;

&lt;p&gt;需要加锁实现，而其它隔离级别通常不需要。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;隔离级别&lt;/th&gt;
      &lt;th&gt;脏读&lt;/th&gt;
      &lt;th&gt;不可重复读&lt;/th&gt;
      &lt;th&gt;幻影读&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;未提交读&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;提交读&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可重复读&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可串行化&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;5多版本并发控制mvcc&quot;&gt;5.多版本并发控制(MVCC)&lt;/h3&gt;

&lt;p&gt;多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。&lt;/p&gt;

&lt;h4 id=&quot;51-版本号&quot;&gt;5.1 版本号&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。&lt;/li&gt;
  &lt;li&gt;事务版本号：事务开始时的系统版本号。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;52-隐藏的列&quot;&gt;5.2 隐藏的列&lt;/h4&gt;

&lt;p&gt;MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建版本号：指示创建一个数据行的快照时的系统版本号；&lt;/li&gt;
  &lt;li&gt;删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;53-undo-日志&quot;&gt;5.3 Undo 日志&lt;/h4&gt;

&lt;p&gt;MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e41405a8-7c05-4f70-8092-e961e28d3112.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;54-实现过程&quot;&gt;5,4 实现过程&lt;/h4&gt;

&lt;p&gt;以下实现过程针对可重复读隔离级别。&lt;/p&gt;

&lt;p&gt;当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SELECT&lt;/p&gt;

    &lt;p&gt;多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。&lt;/p&gt;

    &lt;p&gt;把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;INSERT&lt;/p&gt;

    &lt;p&gt;将当前系统版本号作为数据行快照的创建版本号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DELETE&lt;/p&gt;

    &lt;p&gt;将当前系统版本号作为数据行快照的删除版本号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UPDATE&lt;/p&gt;

    &lt;p&gt;将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;55-快照读与当前读&quot;&gt;5.5 快照读与当前读&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;快照读&lt;/p&gt;

    &lt;p&gt;使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当前读&lt;/p&gt;

    &lt;p&gt;读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;share&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-next-key-locks&quot;&gt;6. Next-Key Locks&lt;/h3&gt;

&lt;p&gt;Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。&lt;/p&gt;

&lt;p&gt;MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。&lt;/p&gt;

&lt;h4 id=&quot;61-record-locks&quot;&gt;6.1 Record Locks&lt;/h4&gt;

&lt;p&gt;锁定一个记录上的索引，而不是记录本身。&lt;/p&gt;

&lt;p&gt;如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。&lt;/p&gt;

&lt;h4 id=&quot;62-gap-locks&quot;&gt;6.2 Gap Locks&lt;/h4&gt;

&lt;p&gt;锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;63-next-key-locks&quot;&gt;6.3 Next-Key Locks&lt;/h4&gt;

&lt;p&gt;它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;∞&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;∞&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-关系数据库设计理论&quot;&gt;7. 关系数据库设计理论&lt;/h3&gt;

&lt;h4 id=&quot;71-函数依赖&quot;&gt;7.1 函数依赖&lt;/h4&gt;

&lt;p&gt;记 A-&amp;gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。&lt;/p&gt;

&lt;p&gt;如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。&lt;/p&gt;

&lt;p&gt;对于 A-&amp;gt;B，如果能找到 A 的真子集 A’，使得 A’-&amp;gt; B，那么 A-&amp;gt;B 就是部分函数依赖，否则就是完全函数依赖。&lt;/p&gt;

&lt;p&gt;对于 A-&amp;gt;B，B-&amp;gt;C，则 A-&amp;gt;C 是一个传递函数依赖。&lt;/p&gt;

&lt;h3 id=&quot;72-异常&quot;&gt;7.2 异常&lt;/h3&gt;

&lt;p&gt;以下的学生课程关系的函数依赖为 {Sno, Cname} -&amp;gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sno&lt;/th&gt;
      &lt;th&gt;Sname&lt;/th&gt;
      &lt;th&gt;Sdept&lt;/th&gt;
      &lt;th&gt;Mname&lt;/th&gt;
      &lt;th&gt;Cname&lt;/th&gt;
      &lt;th&gt;Grade&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;学生-1&lt;/td&gt;
      &lt;td&gt;学院-1&lt;/td&gt;
      &lt;td&gt;院长-1&lt;/td&gt;
      &lt;td&gt;课程-1&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;学生-2&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
      &lt;td&gt;课程-2&lt;/td&gt;
      &lt;td&gt;80&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;学生-2&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
      &lt;td&gt;课程-1&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;学生-3&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
      &lt;td&gt;课程-2&lt;/td&gt;
      &lt;td&gt;95&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;不符合范式的关系，会产生很多异常，主要有以下四种异常：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;冗余数据：例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;学生-2&lt;/code&gt; 出现了两次。&lt;/li&gt;
  &lt;li&gt;修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。&lt;/li&gt;
  &lt;li&gt;删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;课程-1&lt;/code&gt; 需要删除第一行和第三行，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;学生-1&lt;/code&gt; 的信息就会丢失。&lt;/li&gt;
  &lt;li&gt;插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;73-范式&quot;&gt;7.3 范式&lt;/h3&gt;

&lt;p&gt;范式理论是为了解决以上提到四种异常。&lt;/p&gt;

&lt;p&gt;高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。&lt;/p&gt;

&lt;h5 id=&quot;1-第一范式-1nf&quot;&gt;1. 第一范式 (1NF)]&lt;/h5&gt;

&lt;p&gt;属性不可分。&lt;/p&gt;

&lt;h5 id=&quot;2-第二范式-2nf&quot;&gt;2. 第二范式 (2NF)&lt;/h5&gt;

&lt;p&gt;每个非主属性完全函数依赖于键码。&lt;/p&gt;

&lt;p&gt;可以通过分解来满足。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分解前&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sno&lt;/th&gt;
      &lt;th&gt;Sname&lt;/th&gt;
      &lt;th&gt;Sdept&lt;/th&gt;
      &lt;th&gt;Mname&lt;/th&gt;
      &lt;th&gt;Cname&lt;/th&gt;
      &lt;th&gt;Grade&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;学生-1&lt;/td&gt;
      &lt;td&gt;学院-1&lt;/td&gt;
      &lt;td&gt;院长-1&lt;/td&gt;
      &lt;td&gt;课程-1&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;学生-2&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
      &lt;td&gt;课程-2&lt;/td&gt;
      &lt;td&gt;80&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;学生-2&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
      &lt;td&gt;课程-1&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;学生-3&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
      &lt;td&gt;课程-2&lt;/td&gt;
      &lt;td&gt;95&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sno -&amp;gt; Sname, Sdept&lt;/li&gt;
  &lt;li&gt;Sdept -&amp;gt; Mname&lt;/li&gt;
  &lt;li&gt;Sno, Cname-&amp;gt; Grade&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。&lt;/p&gt;

&lt;p&gt;Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分解后&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关系-1&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sno&lt;/th&gt;
      &lt;th&gt;Sname&lt;/th&gt;
      &lt;th&gt;Sdept&lt;/th&gt;
      &lt;th&gt;Mname&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;学生-1&lt;/td&gt;
      &lt;td&gt;学院-1&lt;/td&gt;
      &lt;td&gt;院长-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;学生-2&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;学生-3&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;有以下函数依赖：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sno -&amp;gt; Sname, Sdept&lt;/li&gt;
  &lt;li&gt;Sdept -&amp;gt; Mname&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关系-2&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sno&lt;/th&gt;
      &lt;th&gt;Cname&lt;/th&gt;
      &lt;th&gt;Grade&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;课程-1&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;课程-2&lt;/td&gt;
      &lt;td&gt;80&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;课程-1&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;课程-2&lt;/td&gt;
      &lt;td&gt;95&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;有以下函数依赖：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sno, Cname -&amp;gt; Grade&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;3-第三范式-3nf&quot;&gt;3. 第三范式 (3NF)&lt;/h5&gt;

&lt;p&gt;非主属性不传递函数依赖于键码。&lt;/p&gt;

&lt;p&gt;上面的 关系-1 中存在以下传递函数依赖：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sno -&amp;gt; Sdept -&amp;gt; Mname&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以进行以下分解：&lt;/p&gt;

&lt;p&gt;关系-11&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sno&lt;/th&gt;
      &lt;th&gt;Sname&lt;/th&gt;
      &lt;th&gt;Sdept&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;学生-1&lt;/td&gt;
      &lt;td&gt;学院-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;学生-2&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;学生-3&lt;/td&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;关系-12&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sdept&lt;/th&gt;
      &lt;th&gt;Mname&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;学院-1&lt;/td&gt;
      &lt;td&gt;院长-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;学院-2&lt;/td&gt;
      &lt;td&gt;院长-2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;8-er-图&quot;&gt;8. ER 图&lt;/h3&gt;

&lt;p&gt;Entity-Relationship，有三个组成部分：实体、属性、联系。&lt;/p&gt;

&lt;p&gt;用来进行关系型数据库系统的概念设计。&lt;/p&gt;

&lt;h4 id=&quot;81-实体的三种联系&quot;&gt;8.1 实体的三种联系&lt;/h4&gt;

&lt;p&gt;包含一对一，一对多，多对多三种。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；&lt;/li&gt;
  &lt;li&gt;如果是一对一，画两个带箭头的线段；&lt;/li&gt;
  &lt;li&gt;如果是多对多，画两个不带箭头的线段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图的 Course 和 Student 是一对多的关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;82-表示出现多次的关系&quot;&gt;8.2 表示出现多次的关系&lt;/h4&gt;

&lt;p&gt;一个实体在联系出现几次，就要用几条线连接。&lt;/p&gt;

&lt;p&gt;下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;83-联系的多向性&quot;&gt;8.3 联系的多向性&lt;/h4&gt;

&lt;p&gt;虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;84-表示子类&quot;&gt;8.4 表示子类&lt;/h4&gt;

&lt;p&gt;用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;/h2&gt;

&lt;h3 id=&quot;1-索引&quot;&gt;1. 索引&lt;/h3&gt;

&lt;h4 id=&quot;11--b-tree-原理&quot;&gt;1.1  B+ Tree 原理&lt;/h4&gt;

&lt;h5 id=&quot;111-数据结构&quot;&gt;1.1.1 数据结构&lt;/h5&gt;

&lt;p&gt;B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。&lt;/p&gt;

&lt;p&gt;B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。&lt;/p&gt;

&lt;p&gt;在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;112-操作&quot;&gt;1.1.2 操作&lt;/h5&gt;

&lt;p&gt;进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。&lt;/p&gt;

&lt;p&gt;插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。&lt;/p&gt;

&lt;h5 id=&quot;113-与红黑树的比较&quot;&gt;1.1.3 与红黑树的比较&lt;/h5&gt;

&lt;p&gt;红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;更少的查找次数&lt;/p&gt;

    &lt;p&gt;平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。&lt;/p&gt;

    &lt;p&gt;红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;利用磁盘预读特性&lt;/p&gt;

    &lt;p&gt;为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。&lt;/p&gt;

    &lt;p&gt;操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;12-mysql-索引&quot;&gt;1.2 MySQL 索引&lt;/h4&gt;

&lt;p&gt;索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。&lt;/p&gt;

&lt;h5 id=&quot;121-btree-索引&quot;&gt;1.2.1 B+Tree 索引&lt;/h5&gt;

&lt;p&gt;是大多数 MySQL 存储引擎的默认索引类型。&lt;/p&gt;

&lt;p&gt;因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。&lt;/p&gt;

&lt;p&gt;因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。&lt;/p&gt;

&lt;p&gt;可以指定多个列作为索引列，多个索引列共同组成键。&lt;/p&gt;

&lt;p&gt;适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。&lt;/p&gt;

&lt;p&gt;InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;122-哈希索引&quot;&gt;1.2.2 哈希索引&lt;/h5&gt;

&lt;p&gt;哈希索引能以 O(1) 时间进行查找，但是失去了有序性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无法用于排序与分组；&lt;/li&gt;
  &lt;li&gt;只支持精确查找，无法用于部分查找和范围查找。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。&lt;/p&gt;

&lt;h5 id=&quot;123-全文索引&quot;&gt;1.2.3 全文索引&lt;/h5&gt;

&lt;p&gt;MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。&lt;/p&gt;

&lt;p&gt;查找条件使用 MATCH AGAINST，而不是普通的 WHERE。&lt;/p&gt;

&lt;p&gt;全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。&lt;/p&gt;

&lt;p&gt;InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。&lt;/p&gt;

&lt;h5 id=&quot;124-空间数据索引&quot;&gt;1.2.4. 空间数据索引&lt;/h5&gt;

&lt;p&gt;MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。&lt;/p&gt;

&lt;p&gt;必须使用 GIS 相关的函数来维护数据。&lt;/p&gt;

&lt;h4 id=&quot;13-索引优化&quot;&gt;1.3 索引优化&lt;/h4&gt;

&lt;h5 id=&quot;131-独立的列&quot;&gt;1.3.1 独立的列&lt;/h5&gt;

&lt;p&gt;在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。&lt;/p&gt;

&lt;p&gt;例如下面的查询不能使用 actor_id 列的索引：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sakila&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;132-多列索引&quot;&gt;1.3.2 多列索引&lt;/h5&gt;

&lt;p&gt;在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;film_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sakila&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;film_actor&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;film_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;133-索引列的顺序&quot;&gt;1.3.3 索引列的顺序&lt;/h5&gt;

&lt;p&gt;让选择性最强的索引列放在前面。&lt;/p&gt;

&lt;p&gt;索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。&lt;/p&gt;

&lt;p&gt;例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;staff_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;staff_id_selectivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customer_id_selectivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-pseudocode&quot;&gt;   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;134-前缀索引&quot;&gt;1.3.4 前缀索引&lt;/h5&gt;

&lt;p&gt;对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。&lt;/p&gt;

&lt;p&gt;前缀长度的选取需要根据索引选择性来确定。&lt;/p&gt;

&lt;h5 id=&quot;135-覆盖索引&quot;&gt;1.3.5 覆盖索引&lt;/h5&gt;

&lt;p&gt;索引包含所有需要查询的字段的值。&lt;/p&gt;

&lt;p&gt;具有以下优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。&lt;/li&gt;
  &lt;li&gt;一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。&lt;/li&gt;
  &lt;li&gt;对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;14-索引的优点&quot;&gt;1.4 索引的优点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;大大减少了服务器需要扫描的数据行数。&lt;/li&gt;
  &lt;li&gt;帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。&lt;/li&gt;
  &lt;li&gt;将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;15-索引的使用条件&quot;&gt;1.5 索引的使用条件&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；&lt;/li&gt;
  &lt;li&gt;对于中到大型的表，索引就非常有效；&lt;/li&gt;
  &lt;li&gt;但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-查询性能优化&quot;&gt;2. 查询性能优化&lt;/h3&gt;

&lt;h4 id=&quot;21-使用-explain-进行分析&quot;&gt;2.1 使用 Explain 进行分析&lt;/h4&gt;

&lt;p&gt;Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。&lt;/p&gt;

&lt;p&gt;比较重要的字段有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;select_type : 查询类型，有简单查询、联合查询、子查询等&lt;/li&gt;
  &lt;li&gt;key : 使用的索引&lt;/li&gt;
  &lt;li&gt;rows : 扫描的行数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22-优化数据访问&quot;&gt;2.2 优化数据访问&lt;/h4&gt;

&lt;h5 id=&quot;221-减少请求的数据量&quot;&gt;2.2.1 减少请求的数据量&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;只返回必要的列：最好不要使用 SELECT * 语句。&lt;/li&gt;
  &lt;li&gt;只返回必要的行：使用 LIMIT 语句来限制返回的数据。&lt;/li&gt;
  &lt;li&gt;缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;222-减少服务器端扫描的行数&quot;&gt;2.2.2 减少服务器端扫描的行数&lt;/h5&gt;

&lt;p&gt;最有效的方式是使用索引来覆盖查询。&lt;/p&gt;

&lt;h4 id=&quot;23-重构查询方式&quot;&gt;2.3 重构查询方式&lt;/h4&gt;

&lt;h5 id=&quot;231-切分大查询&quot;&gt;2.3.1 切分大查询&lt;/h5&gt;

&lt;p&gt;一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;messages&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATE_SUB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MONTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-pseudocode&quot;&gt;rows_affected = 0
do {
    rows_affected = do_query(
    &quot;DELETE FROM messages WHERE create  &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)
} while rows_affected &amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;232-分解大连接查询&quot;&gt;2.3.2 分解大连接查询&lt;/h5&gt;

&lt;p&gt;将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。&lt;/li&gt;
  &lt;li&gt;分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。&lt;/li&gt;
  &lt;li&gt;减少锁竞争；&lt;/li&gt;
  &lt;li&gt;在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。&lt;/li&gt;
  &lt;li&gt;查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag_post&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mysql'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mysql'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag_post&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1234&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;456&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;567&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9098&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8904&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-存储引擎&quot;&gt;3. 存储引擎&lt;/h3&gt;

&lt;h4 id=&quot;31-innodb&quot;&gt;3.1 InnoDB&lt;/h4&gt;

&lt;p&gt;是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。&lt;/p&gt;

&lt;p&gt;实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。&lt;/p&gt;

&lt;p&gt;主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。&lt;/p&gt;

&lt;p&gt;内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。&lt;/p&gt;

&lt;p&gt;支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。&lt;/p&gt;

&lt;h4 id=&quot;32-myisam&quot;&gt;3.2 MyISAM&lt;/h4&gt;

&lt;p&gt;设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。&lt;/p&gt;

&lt;p&gt;提供了大量的特性，包括压缩表、空间数据索引等。&lt;/p&gt;

&lt;p&gt;不支持事务。&lt;/p&gt;

&lt;p&gt;不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。&lt;/p&gt;

&lt;p&gt;可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。&lt;/p&gt;

&lt;p&gt;如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。&lt;/p&gt;

&lt;h4 id=&quot;33-比较&quot;&gt;3.3 比较&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外键：InnoDB 支持外键。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份：InnoDB 支持在线热备份。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其它特性：MyISAM 支持压缩表和空间数据索引。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sql中where和having的区别&quot;&gt;sql中where和having的区别&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;“Where” 是一个约束声明，使用Where来约束来自数据库的数据，Where是在结果返回之前起作用的，且&lt;strong&gt;Where中不能使用聚合函数&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;“Having”是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，&lt;strong&gt;在Having中可以使用聚合函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/16/%E5%89%91%E6%8C%87Offer_%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/16/%E5%89%91%E6%8C%87Offer_%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
        
        <category>JobHunting</category>
        
        <category>Foundations</category>
        
        <category>DataBase</category>
        
        
      </item>
    
      <item>
        <title>如何修改 PySpark Dataframe 的列名</title>
        <description>&lt;p&gt;在做Spark Dataframe操作的时候会遇到很多需求. 最近我遇到了一个问题, 就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;agg&lt;/code&gt;方法传入多种聚合函数对多列进行操作, 然后后就生成了多列的聚合结果. 但是列名就是以 原列名+聚合函数的方法, 然后就产生需求 —- 如何修改这些列名呢?&lt;/p&gt;

&lt;p&gt;然后找到了以下方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;selectExpr&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqlContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createDataFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Alberto&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Dakota&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)],&lt;/span&gt; 
                                  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;askdaosdka&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printSchema&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Output
#+-------+----------+
#|   Name|askdaosdka|
#+-------+----------+
#|Alberto|         2|
#| Dakota|         2|
#+-------+----------+
#root
# |-- Name: string (nullable = true)
# |-- askdaosdka: long (nullable = true)
&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selectExpr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Name as name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;askdaosdka as age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printSchema&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Output
#+-------+---+
#|   name|age|
#+-------+---+
#|Alberto|  2|
#| Dakota|  2|
#+-------+---+
#root
# |-- name: string (nullable = true)
# |-- age: long (nullable = true)
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;withColumnRenamed&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;oldColumns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;newColumns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# 这里的reduce是python的reduce
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;functools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withColumnRenamed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldColumns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newColumns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldColumns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printSchema&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;为了便于理解这里给出python &lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;方法的官方解释.&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;functools&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'''
Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value. 
'''&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Roughly equivalent to:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initializer&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initializer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;简单总结一下, 之前看到这种实现方式, 以为是&lt;code class=&quot;highlighter-rouge&quot;&gt;withColumnRenamed&lt;/code&gt;有什么特别高级的实现, 现在结合两部分代买分析一下, 简单来说还是就是通过循环, 反复调用&lt;code class=&quot;highlighter-rouge&quot;&gt;withColumnRenamed&lt;/code&gt;方法给df的column重命名……&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;alias&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pyspark.sql.functions&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alias&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;askdaosdka&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alias&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Output
#+-------+---+
#|   name|age|
#+-------+---+
#|Alberto|  2|
#| Dakota|  2|
#+-------+---+
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlContext.sql&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;sqlContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;registerDataFrameAsTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;myTable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqlContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SELECT Name AS name, askdaosdka as age from myTable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;df2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Output
#+-------+---+
#|   name|age|
#+-------+---+
#|Alberto|  2|
#| Dakota|  2|
#+-------+---+
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说, Pyspark并没有能有一次性对整个column names进行替换的方法, 只能通过一些trick逐个列进行操作. 从个人喜好来说, 第一种和第二种实现方式感觉会相对简单.&lt;/p&gt;

&lt;p&gt;主要方法转载自：&lt;a href=&quot;https://codeday.me/bug/20180407/150940.html&quot;&gt;python – 如何更改pyspark中的数据框列名？&lt;/a&gt; - &lt;a href=&quot;https://codeday.me/&quot;&gt;代码日志&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/15/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9Pyspark-DataFrame%E7%9A%84%E5%88%97%E5%90%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/15/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9Pyspark-DataFrame%E7%9A%84%E5%88%97%E5%90%8D/</guid>
        
        <category>Spark</category>
        
        <category>BigData</category>
        
        <category>Programing</category>
        
        
      </item>
    
      <item>
        <title>Spark OOM 问题的理解与优化</title>
        <description>&lt;p&gt;[toc]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;map执行中内存溢出
map执行中内存溢出代表了所有map类型的操作，包括：&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mapPatitions&lt;/code&gt;等。&lt;/li&gt;
  &lt;li&gt;shuffle后内存溢出
shuffle后内存溢出的shuffle操作包括&lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;reduceByKey&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;repartition&lt;/code&gt;等操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-spark-内存模型&quot;&gt;1. Spark 内存模型：&lt;/h3&gt;

&lt;p&gt;Spark在一个&lt;u&gt;Executor中的内存&lt;/u&gt;分为三块，一块是execution内存，一块是storage内存，一块是other内存。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;execution内存是执行内存，文档中说join，aggregate都在这部分内存中执行，shuffle的数据也会先缓存在这个内存中，满了再写入磁盘，能够减少IO。其实map过程也是在这个内存中执行的。&lt;/li&gt;
  &lt;li&gt;storage内存是存储broadcast，cache，persist数据的地方。&lt;/li&gt;
  &lt;li&gt;other内存是程序执行时预留给自己的内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;execution和storage是Spark Executor中内存的大户，other占用内存相对少很多。&lt;/p&gt;

&lt;p&gt;在spark-1.6.0以前的版本，execution和storage的内存分配是固定的，使用的参数配置分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.memoryFraction&lt;/code&gt;(execution内存占Executor总内存大小，default 0.2)和&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.storage.memoryFraction&lt;/code&gt;(storage内存占Executor内存大小，default 0.6). 因为是1.6.0以前这两块内存是互相隔离的，这就导致了Executor的内存利用率不高，而且需要根据Application的具体情况，使用者自己来调节这两个参数才能优化Spark的内存使用。&lt;/p&gt;

&lt;p&gt;在spark-1.6.0以上的版本，execution内存和storage内存可以相互借用，提高了内存的Spark中内存的使用率，同时也减少了OOM的情况。&lt;/p&gt;

&lt;p&gt;在Spark-1.6.0后加入了&lt;strong&gt;堆外内存&lt;/strong&gt;，进一步优化了Spark的内存使用，堆外内存使用JVM堆以外的内存，不会被gc回收，可以减少频繁的full gc，所以在Spark程序中，会长时间逗留再Spark程序中的大内存对象可以使用堆外内存存储。
使用堆外内存有两种方式，
一种是在rdd调用persist的时候传入参数&lt;code class=&quot;highlighter-rouge&quot;&gt;StorageLevel.OFF_HEAP&lt;/code&gt;，这种使用方式需要配合Tachyon一起使用。
另外一种是使用Spark自带的&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.memory.offHeap.enabled&lt;/code&gt; 配置为true进行使用，但是这种方式在1.6.0的版本还不支持使用，只是多了这个参数，在以后的版本中会开放。&lt;/p&gt;

&lt;p&gt;OOM的问题通常出现在execution这块内存中，因为storage这块内存在存放数据满了之后，会直接丢弃内存中旧的数据，对性能有影响但是不会有OOM的问题。&lt;/p&gt;

&lt;h3 id=&quot;2-内存溢出解决方法&quot;&gt;2. 内存溢出解决方法：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;map过程产生大量对象导致内存溢出：&lt;/p&gt;

    &lt;p&gt;这种溢出的原因是在单个map中产生了大量的对象导致的，例如：&lt;/p&gt;

    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;nv&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这个操作在rdd中，每个对象都产生了10000个对象，这肯定很容易产生内存溢出的问题。针对这种问题，在不增加内存的情况下，可以通过减少每个Task的大小，以便达到每个Task即使产生大量的对象Executor的内存也能够装得下。&lt;strong&gt;具体做法&lt;/strong&gt;可以在会产生大量对象的map操作之前调用&lt;code class=&quot;highlighter-rouge&quot;&gt;repartition&lt;/code&gt;方法，分区成&lt;u&gt;更小的块&lt;/u&gt;传入map。例如：&lt;/p&gt;

    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;nv&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;repartition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;面对这种问题注意，不能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.coalesce&lt;/code&gt;方法，这个方法只能减少分区，不能增加分区，不会有shuffle的过程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据不平衡导致内存溢出：&lt;/p&gt;

    &lt;p&gt;数据不平衡除了有可能导致内存溢出外，也有可能导致性能的问题，解决方法和上面说的类似，就是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;repartition&lt;/code&gt;重新分区。这里就不再累赘了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;coalesce&lt;/code&gt;调用导致内存溢出：&lt;/p&gt;

    &lt;p&gt;因为hdfs中不适合存小问题，所以Spark计算后如果产生的文件太小，我们会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;coalesce&lt;/code&gt;合并文件再存入hdfs中。但是这会导致一个问题，例如在&lt;code class=&quot;highlighter-rouge&quot;&gt;coalesce&lt;/code&gt;之前有100个文件，这也意味着能够有100个Task，现在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;coalesce(10)&lt;/code&gt;，最后只产生10个文件，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;coalesce&lt;/code&gt;并不是shuffle操作，这意味着&lt;code class=&quot;highlighter-rouge&quot;&gt;coalesce&lt;/code&gt;并不是按照我原本想的那样先执行100个Task，再将Task的执行结果合并成10个，而是从头到位只有10个Task在执行，原本100个文件是分开执行的，现在每个Task同时一次读取10个文件，使用的内存是原来的10倍，这导致了OOM。解决这个问题的方法是令程序按照我们想的先执行100个Task再将结果合并成10个文件，这个问题同样可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;repartition&lt;/code&gt;解决，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;repartition(10)&lt;/code&gt;，因为这就有一个shuffle的过程，shuffle前后是两个Stage，一个100个分区，一个是10个分区，就能按照我们的想法执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;shuffle后内存溢出:&lt;/p&gt;

    &lt;p&gt;shuffle内存溢出的情况可以说都是shuffle后，&lt;u&gt;单个文件过大&lt;/u&gt;导致的。
在Spark中，&lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;reduceByKey&lt;/code&gt;这一类型的过程，都会有shuffle的过程，在shuffle的使用，需要传入一个partitioner，大部分Spark中的shuffle操作，默认的partitioner都是&lt;code class=&quot;highlighter-rouge&quot;&gt;HashPatitioner&lt;/code&gt;，默认值是父RDD中&lt;u&gt;最大的分区数&lt;/u&gt;, 这个参数通过下面两个参数控制:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;RDD: &lt;code class=&quot;highlighter-rouge&quot;&gt;spark.default.parallelism&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;DataFrame: &lt;code class=&quot;highlighter-rouge&quot;&gt;spark.sql.shuffle.partitions&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.default.parallelism&lt;/code&gt;参数只对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashPartitioner&lt;/code&gt;有效，所以如果是别的Partitioner或者自己实现的Partitioner就不能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.default.parallelism&lt;/code&gt;这个参数来控制shuffle的并发量了。如果是别的partitioner导致的shuffle内存溢出，就需要从partitioner的代码增加partitions的数量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;standalone模式下资源分配不均匀导致内存溢出：
 在standalone的模式下如果配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;--total-executor-cores&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;--executor-memory&lt;/code&gt; 这两个参数，但是没有配置&lt;code class=&quot;highlighter-rouge&quot;&gt;--executor-cores&lt;/code&gt;这个参数的话，就有可能导致，每个Executor的&lt;strong&gt;memory&lt;/strong&gt;是一样的，但是&lt;strong&gt;cores&lt;/strong&gt;的数量不同，那么在cores数量多的Executor中，由于能够同时执行多个Task，就容易导致内存溢出的情况。这种情况的解决方法就是同时配置&lt;code class=&quot;highlighter-rouge&quot;&gt;--executor-cores&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.executor.cores&lt;/code&gt;参数，确保Executor资源分配均匀。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在RDD中，共用对象能够减少OOM的情况：&lt;/p&gt;

    &lt;p&gt;这个比较特殊，有一种情况，类似这样&lt;/p&gt;

    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;导致OOM，但是在同样的情况下，使用&lt;/p&gt;

    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;就不会有OOM的问题，这是因为每次&lt;code class=&quot;highlighter-rouge&quot;&gt;(&quot;key&quot;,&quot;value&quot;)&lt;/code&gt;都产生一个Tuple对象，而”key”+”value”，不管多少个，都只有一个对象，指向常量池。具体测试如下：&lt;/p&gt;

    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;false&lt;/span&gt;
   
&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这个例子说明(“key”,”value”)和(“key”,”value”)在内存中是存在不同位置的,也就是存了两份,但是”key”+”value”虽然出现了两次,但是只存了一份,在同一个地址,这用到了JVM常量池的知识. 于是乎,如果RDD中有大量的重复数据,或者Array中需要存大量重复数据的时候我们都可以将重复数据转化为String,能够有效的减少内存使用.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-优化策略&quot;&gt;3. 优化策略：&lt;/h3&gt;

&lt;p&gt;这一部分主要记录一下到spark-1.6.1版本，笔者觉得有优化性能作用的一些参数配置和一些代码优化技巧，在参数优化部分，如果笔者觉得默认值是最优的了，这里就不再记录。&lt;/p&gt;
&lt;h4 id=&quot;代码优化技巧&quot;&gt;代码优化技巧：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;mapPartitions&lt;/code&gt;代替大部分&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;操作，或者连续使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;操作：&lt;/p&gt;

    &lt;p&gt;这里需要稍微讲一下RDD和DataFrame的区别。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;RDD强调的是&lt;strong&gt;不可变对象&lt;/strong&gt;，每个RDD都是不可变的，当调用RDD的map类型操作的时候，都是产生一个新的对象，这就导致了一个问题，如果对一个RDD调用大量的map类型操作的话，每个map操作会产生一个到多个RDD对象，这虽然不一定会导致内存溢出，但是会产生大量的中间数据，&lt;u&gt;增加了gc操作&lt;/u&gt;。另外RDD在调用action操作的时候，会出发Stage的划分，但是在每个Stage内部可优化的部分是不会进行优化的，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.map(_+1).map(_+1)&lt;/code&gt;，这个操作在数值型RDD中是等价于rdd.map(_+2)的，但是RDD内部不会对这个过程进行优化。&lt;/li&gt;
      &lt;li&gt;DataFrame则不同，DataFrame由于有类型信息所以是&lt;strong&gt;可变的&lt;/strong&gt;，并且在可以使用sql的程序中，都有除了解释器外，都会有一个sql优化器，DataFrame也不例外，有一个优化器Catalyst，具体介绍看后面参考的文章。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;上面说到的这些RDD的弊端，有一部分就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;mapPartitions&lt;/code&gt;进行优化，&lt;code class=&quot;highlighter-rouge&quot;&gt;mapPartitions&lt;/code&gt;可以同时替代&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.filter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.flatMap&lt;/code&gt;的作用，所以在长操作中，可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;mapPartitons&lt;/code&gt;中将RDD大量的操作写在一起，避免产生大量的中间rdd对象，另外是mapPartitions在一个partition中可以复用可变类型，这也能够避免频繁的创建新对象。使用mapPartitions的弊端就是牺牲了代码的易读性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast join&lt;/code&gt;和普通&lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;：&lt;/p&gt;

    &lt;p&gt;在大数据分布式系统中，大量数据的移动对性能的影响也是巨大的。基于这个思想，在两个RDD进行join操作的时候，如果其中一个RDD相对小很多，可以将小的RDD进行&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;操作然后设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt;变量，这样做之后，另一个RDD就可以使用map操作进行join，这样能够有效的减少相对大很多的那个RDD的数据移动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;：&lt;/p&gt;

    &lt;p&gt;这个就是&lt;strong&gt;谓词下推&lt;/strong&gt;，这个很显然，filter之后再join，shuffle的数据量会减少，这里提一点是spark-sql的优化器已经对这部分有优化了，不需要用户显示的操作，个人实现rdd的计算的时候需要注意这个。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;partitonBy优化：&lt;/p&gt;

    &lt;p&gt;这一部分在另一篇文章《spark partitioner使用技巧 》有详细介绍，这里不说了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;combineByKey的使用：
 这个操作在Map-Reduce中也有，这里举个例子：&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.groupByKey().mapValue(_.sum)&lt;/code&gt;比&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.reduceByKey&lt;/code&gt;的效率低，原因如下两幅图所示(网上盗来的，侵删)&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/739727/201801/739727-20180126174937069-1579617042.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/739727/201801/739727-20180126175121959-313725154.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;上下两幅图的区别就是上面那幅有&lt;code class=&quot;highlighter-rouge&quot;&gt;combineByKey&lt;/code&gt;的过程减少了shuffle的数据量，下面的没有。&lt;code class=&quot;highlighter-rouge&quot;&gt;combineByKey&lt;/code&gt;是key-value型rdd自带的API，可以直接使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在内存不足的使用，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.persist(StorageLevel.MEMORY_AND_DISK_SER)&lt;/code&gt;代替&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.cache()&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.cache()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.persist(Storage.MEMORY_ONLY)&lt;/code&gt;是等价的，在内存不足的时候&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.cache()&lt;/code&gt;的数据会丢失，&lt;u&gt;再次使用的时候会重算&lt;/u&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;rdd.persist(StorageLevel.MEMORY_AND_DISK_SER)&lt;/code&gt;在内存不足的时候会存储在磁盘，避免重算，只是消耗点IO时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在spark使用hbase的时候，spark和hbase搭建在同一个集群：&lt;/p&gt;

    &lt;p&gt;在spark结合hbase的使用中，spark和hbase最好搭建在同一个集群上上，或者spark的集群节点能够覆盖hbase的所有节点。hbase中的数据存储在HFile中，通常单个HFile都会比较大，另外Spark在读取Hbase的数据的时候，不是按照一个HFile对应一个RDD的分区，而是一个region对应一个RDD分区。所以在Spark读取Hbase的数据时，通常单个RDD都会比较大，如果不是搭建在同一个集群，数据移动会耗费很多的时间。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;参数优化部分&quot;&gt;参数优化部分：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.driver.memory&lt;/code&gt; (default 1G)：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个参数用来设置Driver的内存。在Spark程序中，SparkContext，DAGScheduler都是运行在Driver端的。对应rdd的Stage切分也是在Driver端运行，如果用户自己写的程序有过多的步骤，切分出过多的Stage，这部分信息消耗的是Driver的内存，这个时候就需要调大Driver的内存。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.rdd.compress&lt;/code&gt; (default false) ：&lt;/p&gt;

    &lt;p&gt;这个参数在内存吃紧的时候，又需要persist数据有良好的性能，就可以设置这个参数为true，这样在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;persist(StorageLevel.MEMORY_ONLY_SER)&lt;/code&gt;的时候，就能够压缩内存中的rdd数据。减少内存消耗，就是在使用的时候会占用CPU的解压时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.serializer&lt;/code&gt; (default &lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.spark.serializer.JavaSerializer&lt;/code&gt; )&lt;/p&gt;

    &lt;p&gt;建议设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.spark.serializer.KryoSerializer&lt;/code&gt;，因为KryoSerializer比JavaSerializer快，但是有可能会有些Object会序列化失败，这个时候就需要显示的对序列化失败的类进行KryoSerializer的注册，这个时候要配置spark.kryo.registrator参数或者使用参照如下代码：&lt;/p&gt;

    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;valconf&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;newSparkConf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setMaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setAppName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;registerKryoClasses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyClass1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyClass2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;valsc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;newSparkContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.memory.storageFraction&lt;/code&gt; (default 0.5)&lt;/p&gt;

    &lt;p&gt;‘这个参数设置内存表示 Executor内存中 storage/(storage+execution)，虽然spark-1.6.0+的版本内存storage和execution的内存已经是可以互相借用的了，但是借用和赎回也是需要消耗性能的，所以如果明知道程序中storage是多是少就可以调节一下这个参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.locality.wait&lt;/code&gt; (default 3s)：&lt;/p&gt;

    &lt;p&gt;spark中有4种本地化执行level，
&lt;code class=&quot;highlighter-rouge&quot;&gt;PROCESS_LOCAL&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NODE_LOCAL&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RACK_LOCAL&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ANY&lt;/code&gt;,
一个task执行完，等待spark.locality.wait时间如果，第一次等待PROCESS的Task到达，如果没有，等待任务的等级下调到NODE再等待spark.locality.wait时间，依次类推，直到ANY。分布式系统是否能够很好的执行本地文件对性能的影响也是很大的。如果RDD的每个分区数据比较多，每个分区处理时间过长，就应该把 spark.locality.wait 适当调大一点，让Task能够有更多的时间等待本地数据。特别是在使用persist或者cache后，这两个操作过后，在本地机器调用内存中保存的数据效率会很高，但是如果需要跨机器传输内存中的数据，效率就会很低。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.speculation&lt;/code&gt; (default false):&lt;/p&gt;

    &lt;p&gt;一个大的集群中，每个节点的性能会有差异，spark.speculation这个参数表示空闲的资源节点会不会尝试执行还在运行，并且运行时间过长的Task，避免单个节点运行速度过慢导致整个任务卡在一个节点上。这个参数最好设置为true。与之相配合可以一起设置的参数有&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.speculation.*&lt;/code&gt;开头的参数。参考中有文章详细说明这个参数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;http://www.jianshu.com/p/c0181667daa0&lt;/li&gt;
  &lt;li&gt;http://www.csdn.net/article/2015-06-18/2824958&lt;/li&gt;
  &lt;li&gt;https://chenzhongpu.gitbooks.io/bigdatanotes/content/SparkSQLOptimizer/index.html&lt;/li&gt;
  &lt;li&gt;http://book.51cto.com/art/201409/453045.html&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文链接：https://blog.csdn.net/yhb315279058/article/details/51035631&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/10/Spark-OOM%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/10/Spark-OOM%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
        
        <category>Spark</category>
        
        <category>Programing</category>
        
        <category>BigData</category>
        
        
      </item>
    
      <item>
        <title>深入理解Spark Shuffle</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;shuffle带来的问题&quot;&gt;Shuffle带来的问题&lt;/h2&gt;

&lt;p&gt;在Spark大规模数据处理中，因为shuffle后出现OOM问题非常常见, 深入理解shuffle前先从实际问题出发.&lt;/p&gt;

&lt;h3 id=&quot;报错提示&quot;&gt;报错提示&lt;/h3&gt;

&lt;h4 id=&quot;sparksql-shuffle操作带来的报错&quot;&gt;SparkSQL shuffle操作带来的报错&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;org.apache.spark.shuffle.MetadataFetchFailedException: 
Missing an output location &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;shuffle 0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;org.apache.spark.shuffle.FetchFailedException:
Failed to connect to &lt;span class=&quot;nb&quot;&gt;hostname&lt;/span&gt;/192.168.xx.xxx:50268
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;rdd的shuffle操作带来的报错&quot;&gt;RDD的shuffle操作带来的报错&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;WARN TaskSetManager: Lost task 17.1 in stage 4.1 (TID 1386, spark050013): java.io.FileNotFoundException: /data04/spark/tmp/blockmgr-817d372f-c359-4a00-96dd-8f6554aa19cd/2f/temp_shuffle_e22e013a-5392-4edb-9874-a196a1dad97c (没有那个文件或目录)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;FetchFailed(BlockManagerId(6083b277-119a-49e8-8a49-3539690a2a3f-S155, spark050013, 8533), shuffleId=1, mapId=143, reduceId=3, message=
org.apache.spark.shuffle.FetchFailedException: Error in opening FileSegmentManagedBuffer{file=/data04/spark/tmp/blockmgr-817d372f-c359-4a00-96dd-8f6554aa19cd/0e/shuffle_1_143_0.data, offset=997061, length=112503}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;原因&quot;&gt;原因&lt;/h3&gt;

&lt;p&gt;shuffle分为&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle write&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle read&lt;/code&gt;两部分。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle write&lt;/code&gt;的分区数由上一阶段的RDD分区数控制，&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle read&lt;/code&gt;的分区数则是由Spark提供的一些参数控制。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle write&lt;/code&gt;可以简单理解为类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;saveAsLocalDiskFile&lt;/code&gt;的操作，将计算的中间结果按某种规则临时放到各个executor所在的本地磁盘上。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle read&lt;/code&gt;的时候数据的分区数则是由spark提供的一些参数控制。可以想到的是，如果这个参数值设置的很小，同时&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle read&lt;/code&gt;的量很大，那么将会导致一个task需要处理的数据非常大。结果导致&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM crash&lt;/code&gt;，从而导致取shuffle数据失败，同时executor也丢失了，看到&lt;code class=&quot;highlighter-rouge&quot;&gt;Failed to connect to host&lt;/code&gt;的错误，也就是executor lost的意思。有时候即使不会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM crash&lt;/code&gt;也会造成长时间的&lt;code class=&quot;highlighter-rouge&quot;&gt;gc&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;知道原因后问题就好解决了，主要从shuffle的数据量和处理shuffle数据的分区数两个角度入手。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;减少shuffle数据&lt;/p&gt;

    &lt;p&gt;思考是否可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;map side join&lt;/code&gt;或是&lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast join&lt;/code&gt;来规避shuffle的产生。&lt;/p&gt;

    &lt;p&gt;将不必要的数据在shuffle前进行过滤，比如原始数据有20个字段，只要选取需要的字段进行处理即可，将会减少一定的shuffle数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SparkSQL和DataFrame的&lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;group by&lt;/code&gt;等操作&lt;/p&gt;

    &lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.sql.shuffle.partitions&lt;/code&gt;控制分区数，默认为200，根据shuffle的量以及计算的复杂度提高这个值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Rdd的&lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reduceByKey&lt;/code&gt;等操作&lt;/p&gt;

    &lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.default.parallelism&lt;/code&gt;控制&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle read&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;处理的分区数，默认为运行任务的core的总数（mesos细粒度模式为8个，local模式为本地的core总数），官方建议为设置成运行任务的core的2-3倍。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提高executor的内存&lt;/p&gt;

    &lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.executor.memory&lt;/code&gt;适当提高executor的memory值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;是否存在数据倾斜的问题&lt;/p&gt;

    &lt;p&gt;空值是否已经过滤？异常数据（某个key数据特别大）是否可以单独处理？考虑改变数据分区规则。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文链接：https://blog.csdn.net/lsshlsw/article/details/51213610&lt;/p&gt;

&lt;h2 id=&quot;spark-shuffle的基本原理与特性&quot;&gt;Spark Shuffle的基本原理与特性&lt;/h2&gt;

&lt;p&gt;与MapReduce计算框架一样，Spark的Shuffle实现大致如下图所示，在DAG阶段以shuffle为界，划分stage，上游stage做map task，每个map task将计算结果数据分成多份，每一份对应到下游stage的每个partition中，并将其临时写到磁盘，该过程叫做shuffle write；下游stage做reduce task，每个reduce task通过网络拉取上游stage中所有map task的指定分区结果数据，该过程叫做shuffle read，最后完成reduce的业务逻辑。举个栗子，假如上游stage有100个map task，下游stage有1000个reduce task，那么这100个map task中每个map task都会得到1000份数据，而1000个reduce task中的每个reduce task都会拉取上游100个map task对应的那份数据，即第一个reduce task会拉取所有map task结果数据的第一份，以此类推。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sharkdtu.com/images/spark-shuffle-overview.png&quot;&gt;&lt;img src=&quot;http://sharkdtu.com/images/spark-shuffle-overview.png&quot; alt=&quot;spark-shuffle-overview&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在map阶段，除了map的业务逻辑外，还有shuffle write的过程，这个过程涉及到序列化、磁盘IO等耗时操作；在reduce阶段，除了reduce的业务逻辑外，还有前面shuffle read过程，这个过程涉及到网络IO、反序列化等耗时操作。所以整个shuffle过程是极其昂贵的，spark在shuffle的实现上也做了很多优化改进，随着版本的迭代发布，spark shuffle的实现也逐步得到改进。下面详细介绍spark shuffle的实现演进过程。&lt;/p&gt;

&lt;h2 id=&quot;spark-shuffle实现演进&quot;&gt;Spark Shuffle实现演进&lt;/h2&gt;

&lt;p&gt;Spark在1.1以前的版本一直是采用Hash Shuffle的实现的方式，到1.1版本时参考Hadoop MapReduce的实现开始引入Sort Shuffle，在1.5版本时开始Tungsten钨丝计划，引入UnSafe Shuffle优化内存及CPU的使用，在1.6中将Tungsten统一到Sort Shuffle中，实现自我感知选择最佳Shuffle方式，到最近的2.0版本，Hash Shuffle已被删除，所有Shuffle方式全部统一到Sort Shuffle一个实现中。下图是spark shuffle实现的一个版本演进。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sharkdtu.com/images/spark-shuffle-evolution.png&quot;&gt;&lt;img src=&quot;http://sharkdtu.com/images/spark-shuffle-evolution.png&quot; alt=&quot;spark-shuffle-evolution&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;hash-shuffle-v1&quot;&gt;Hash Shuffle v1&lt;/h3&gt;

&lt;p&gt;在spark-1.1版本以前，spark内部实现的是Hash Shuffle，其大致原理与前面基本原理介绍中提到的基本一样，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sharkdtu.com/images/spark-shuffle-v1.png&quot;&gt;&lt;img src=&quot;http://sharkdtu.com/images/spark-shuffle-v1.png&quot; alt=&quot;spark-shuffle-v1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在map阶段(shuffle write)，每个map都会为下游stage的每个partition写一个临时文件，假如下游stage有1000个partition，那么每个map都会生成1000个临时文件，一般来说一个executor上会运行多个map task，这样下来，一个executor上会有非常多的临时文件，假如一个executor上运行M个map task，下游stage有N个partition，那么一个executor上会生成M&lt;em&gt;N个文件。另一方面，如果一个executor上有K个core，那么executor同时可运行K个task，这样一来，就会同时申请K&lt;/em&gt;N个文件描述符，一旦partition数较多，势必会耗尽executor上的文件描述符，同时生成K*N个write handler也会带来大量内存的消耗。&lt;/p&gt;

&lt;p&gt;在reduce阶段(shuffle read)，每个reduce task都会拉取所有map对应的那部分partition数据，那么executor会打开所有临时文件准备网络传输，这里又涉及到大量文件描述符，另外，如果reduce阶段有combiner操作，那么它会把网络中拉到的数据保存在一个&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;中进行合并操作，如果数据量较大，很容易引发OOM操作。&lt;/p&gt;

&lt;p&gt;综上所述，Hash Shuffle实现简单但是特别naive，在小数据量下运行比较快，一旦数据量较大，基本就垮了。当然这个版本的shuffle也是在spark早期版本中，随着版本迭代的进行，shuffle的实现也越来越成熟。&lt;/p&gt;

&lt;h3 id=&quot;hash-shuffle-v2&quot;&gt;Hash Shuffle v2&lt;/h3&gt;

&lt;p&gt;在上一节讲到每个map task都要生成N个partition文件，为了减少文件数，后面引进了，目的是减少单个executor上的文件数。如下图所示，一个executor上所有的map task生成的分区文件只有一份，即将所有的map task相同的分区文件合并，这样每个executor上最多只生成N个分区文件。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sharkdtu.com/images/spark-shuffle-v2.png&quot;&gt;&lt;img src=&quot;http://sharkdtu.com/images/spark-shuffle-v2.png&quot; alt=&quot;spark-shuffle-v2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;表面上看是减少了文件数，但是假如下游stage的分区数N很大，还是会在每个executor上生成N个文件，同样，如果一个executor上有K个core，还是会开K*N个writer handler，总体上来说基本没太解决问题。对于shuffle read阶段跟v1版一样没改进，仍然容易导致OOM。&lt;/p&gt;

&lt;h3 id=&quot;sort-shuffle-v1&quot;&gt;Sort Shuffle v1&lt;/h3&gt;

&lt;p&gt;针对上述Hash Shuffle的弊端，在spark 1.1.0版本中引入Sort Shuffle，它参考了Hadoop MapReduce中的shuffle实现，对记录进行排序来做shuffle，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sharkdtu.com/images/spark-shuffle-v3.png&quot;&gt;&lt;img src=&quot;http://sharkdtu.com/images/spark-shuffle-v3.png&quot; alt=&quot;spark-shuffle-v3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在map阶段(shuffle write)，会按照partition id以及key对记录进行排序，将所有partition的数据写在同一个文件中，该文件中的记录首先是按照partition id排序一个一个分区的顺序排列，每个partition内部是按照key进行排序存放，map task运行期间会顺序写每个partition的数据，并通过一个索引文件记录每个partition的大小和偏移量。这样一来，每个map task一次只开两个文件描述符，一个写数据，一个写索引，大大减轻了Hash Shuffle大量文件描述符的问题，即使一个executor有K个core，那么最多一次性开K*2个文件描述符。&lt;/p&gt;

&lt;p&gt;在reduce阶段(shuffle read)，reduce task拉取数据做combine时不再是采用&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;，而是采用&lt;code class=&quot;highlighter-rouge&quot;&gt;ExternalAppendOnlyMap&lt;/code&gt;，该数据结构在做combine时，如果内存不足，会刷写磁盘，很大程度的保证了鲁棒性，避免大数据情况下的OOM。&lt;/p&gt;

&lt;p&gt;总体上看来Sort Shuffle解决了Hash Shuffle的所有弊端，但是因为需要其shuffle过程需要对记录进行排序，所以在性能上有所损失。&lt;/p&gt;

&lt;h3 id=&quot;unsafe-shuffle&quot;&gt;Unsafe Shuffle&lt;/h3&gt;

&lt;p&gt;从spark 1.5.0开始，spark开始了钨丝计划(Tungsten)，目的是优化内存和CPU的使用，进一步提升spark的性能。为此，引入Unsafe Shuffle，它的做法是将数据记录用二进制的方式存储，直接在序列化的二进制数据上sort而不是在java 对象上，这样一方面可以减少memory的使用和GC的开销，另一方面避免shuffle过程中频繁的序列化以及反序列化。在排序过程中，它提供cache-efficient sorter，使用一个8 bytes的指针，把排序转化成了一个指针数组的排序，极大的优化了排序性能。更多Tungsten详细介绍请移步&lt;a href=&quot;https://databricks.com/blog/2015/04/28/project-tungsten-bringing-spark-closer-to-bare-metal.html&quot;&gt;databricks博客&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;但是使用Unsafe Shuffle有几个限制，shuffle阶段不能有aggregate操作，分区数不能超过一定大小(224−1224−1，这是可编码的最大parition id)，所以像reduceByKey这类有aggregate操作的算子是不能使用Unsafe Shuffle，它会退化采用Sort Shuffle。&lt;/p&gt;

&lt;h3 id=&quot;sort-shuffle-v2&quot;&gt;Sort Shuffle v2&lt;/h3&gt;

&lt;p&gt;从spark-1.6.0开始，把Sort Shuffle和Unsafe Shuffle全部统一到Sort Shuffle中，如果检测到满足Unsafe Shuffle条件会自动采用Unsafe Shuffle，否则采用Sort Shuffle。从spark-2.0.0开始，spark把Hash Shuffle移除，可以说目前spark-2.0中只有一种Shuffle，即为Sort Shuffle。&lt;/p&gt;

&lt;h2 id=&quot;spark-shuffle相关调优&quot;&gt;Spark Shuffle相关调优&lt;/h2&gt;

&lt;p&gt;从上述shuffle的原理介绍可以知道，shuffle是一个涉及到CPU(序列化反序列化)、网络IO(跨节点数据传输)以及磁盘IO(shuffle中间结果落地)的操作，用户在编写spark应用程序的时候应当尽可能考虑shuffle相关的优化，提升spark应用程序的性能。下面简单列举几点关于spark shuffle调优的参考。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尽量减少shuffle次数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 两次shuffle
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;repartition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;reduceByKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 一次shuffle
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;repartition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;reduceByKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;必要时主动shuffle，通常用于改变并行度，提高后续分布式运行速度&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;rdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;repartiton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largerNumPartition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...)...&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;使用treeReduce &amp;amp; treeAggregate替换reduce &amp;amp; aggregate。数据量较大时，reduce &amp;amp; aggregate一次性聚合，shuffle量太大，而treeReduce &amp;amp; treeAggregate是分批聚合，更为保险。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;什么时候需要-shuffle-writer&quot;&gt;什么时候需要 shuffle writer&lt;/h3&gt;

&lt;p&gt;假如我们有个 spark job 依赖关系如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/75fd68334b09d27077b70388fa5a9e7b&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们抽象出来其中的rdd和依赖关系，如果对这块不太清楚的可以参考我们之前的 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjY2MTYzMA==&amp;amp;mid=2247483846&amp;amp;idx=1&amp;amp;sn=ad5c6cb542d67e453972795743022298&amp;amp;scene=21#wechat_redirect&quot;&gt;彻底搞懂spark stage 划分&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的 划分后的RDD结构为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/bfa9fb7e1c09bff43c86a729ca2b2622&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终我们得到了整个执行过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/a6131c4afa406e5b06b930cdea92fcf4&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中间就涉及到shuffle 过程，前一个stage 的 ShuffleMapTask 进行 shuffle write， 把数据存储在 blockManager 上面， 并且把数据位置元信息上报到 driver 的 mapOutTrack 组件中， 下一个 stage 根据数据位置元信息， 进行 shuffle read， 拉取上个stage 的输出数据。&lt;/p&gt;

&lt;p&gt;这边文章讲述的就是其中的 shuffle write 过程。&lt;/p&gt;

&lt;h3 id=&quot;spark-shuffle-演进的历史&quot;&gt;spark shuffle 演进的历史&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Spark 0.8及以前 Hash Based Shuffle&lt;/li&gt;
  &lt;li&gt;Spark 0.8.1 为Hash Based Shuffle引入File Consolidation机制&lt;/li&gt;
  &lt;li&gt;Spark 0.9 引入ExternalAppendOnlyMap&lt;/li&gt;
  &lt;li&gt;Spark 1.1 引入Sort Based Shuffle，但默认仍为Hash Based Shuffle&lt;/li&gt;
  &lt;li&gt;Spark 1.2 默认的Shuffle方式改为Sort Based Shuffle&lt;/li&gt;
  &lt;li&gt;Spark 1.4 引入Tungsten-Sort Based Shuffle&lt;/li&gt;
  &lt;li&gt;Spark 1.6 Tungsten-sort并入Sort Based Shuffle&lt;/li&gt;
  &lt;li&gt;Spark 2.0 Hash Based Shuffle退出历史舞台&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结一下， 就是最开始的时候使用的是 Hash Based Shuffle， 这时候每一个Mapper会根据Reducer的数量创建出相应的bucket，bucket的数量是M &lt;em&gt;R ，其中M是Map的个数，R是Reduce的个数。这样会产生大量的小文件，对文件系统压力很大，而且也不利于IO吞吐量。后面忍不了了就做了优化，把在统一core上运行的多个Mapper 输出的合并到同一个文件，这样文件数目就变成了 cores&lt;/em&gt; R 个了，&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;本来是这样的，3个 map task， 3个 reducer， 会产生 9个小文件，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/2a9cddc8267eaf96e3d51822e75fe0b2&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是不是很恐怖， 后面改造之后&lt;/p&gt;

&lt;p&gt;4个map task， 4个reducer， 如果不使用 Consolidation机制， 会产生 16个小文件。&lt;/p&gt;

&lt;p&gt;但是但是现在这 4个 map task 分两批运行在 2个core上， 这样只会产生 8个小文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/8a4d042d1c8a031a5091521c2c76d262&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在同一个 core 上先后运行的两个 map task的输出， 对应同一个文件的不同的 segment上， 称为一个 FileSegment， 形成一个 ShuffleBlockFile，&lt;/p&gt;

&lt;p&gt;后面就引入了  Sort Based Shuffle， map端的任务会按照Partition id以及key对记录进行排序。同时将全部结果写到一个数据文件中，同时生成一个索引文件， 再后面就就引入了 Tungsten-Sort Based Shuffle， 这个是直接使用堆外内存和新的内存管理模型，节省了内存空间和大量的gc， 是为了提升性能。&lt;/p&gt;

&lt;p&gt;现在2.1 分为三种writer， 分为 BypassMergeSortShuffleWriter， SortShuffleWriter 和 UnsafeShuffleWriter，顾名思义，大家应该可以对应上，我们本着过时不讲的原则， 本文中只描述这三种 writer 的实现细节， Hash Based Shuffle 已经退出历史舞台了，我就不讲了。&lt;/p&gt;

&lt;h3 id=&quot;三种-writer-的分类&quot;&gt;三种 writer 的分类&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/8c6f0cae9d50f699cb3a39f4060ea2fe&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面是使用哪种 writer 的判断依据， 是否开启 mapSideCombine 这个判断，是因为有些算子会在 map 端先进行一次 combine， 减少传输数据。 因为 BypassMergeSortShuffleWriter 会临时输出Reducer个（分区数目）小文件，所以分区数必须要小于一个阀值，默认是小于200。&lt;/p&gt;

&lt;p&gt;UnsafeShuffleWriter需要Serializer支持relocation，Serializer支持relocation：原始数据首先被序列化处理，并且再也不需要反序列，在其对应的元数据被排序后，需要Serializer支持relocation，在指定位置读取对应数据。&lt;/p&gt;

&lt;h3 id=&quot;bypassmergesortshufflewriter-实现细节&quot;&gt;BypassMergeSortShuffleWriter 实现细节&lt;/h3&gt;

&lt;p&gt;BypassMergeSortShuffleWriter和Hash Shuffle中的HashShuffleWriter实现基本一致， 唯一的区别在于，map端的多个输出文件会被汇总为一个文件。 所有分区的数据会合并为同一个文件，会生成一个索引文件，是为了索引到每个分区的起始地址，可以随机 access 某个partition的所有数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/c695dc3a759a5133c38adbd989a03d8d&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是需要注意的是，这种方式不宜有太多分区，因为过程中会并发打开所有分区对应的临时文件，会对文件系统造成很大的压力。&lt;/p&gt;

&lt;p&gt;具体实现就是给每个分区分配一个临时文件，对每个 record的key 使用分区器（模式是hash，如果用户自定义就使用自定义的分区器）找到对应分区的输出文件句柄，直接写入文件，没有在内存中使用 buffer。 最后copyStream方法把所有的临时分区文件拷贝到最终的输出文件中，并且记录每个分区的文件起始写入位置，把这些位置数据写入索引文件中。&lt;/p&gt;

&lt;h3 id=&quot;sortshufflewriter-实现细节&quot;&gt;SortShuffleWriter 实现细节&lt;/h3&gt;

&lt;p&gt;我们可以先考虑一个问题，假如我有 100亿条数据，但是我们的内存只有1M，但是我们磁盘很大， 我们现在要对这100亿条数据进行排序，是没法把所有的数据一次性的load进行内存进行排序的，这就涉及到一个外部排序的问题，我们的1M内存只能装进1亿条数据，每次都只能对这 1亿条数据进行排序，排好序后输出到磁盘，总共输出100个文件，最后怎么把这100个文件进行merge成一个全局有序的大文件。我们可以每个文件（有序的）都取一部分头部数据最为一个 buffer， 并且把这 100个 buffer放在一个堆里面，进行堆排序，比较方式就是对所有堆元素（buffer）的head元素进行比较大小， 然后不断的把每个堆顶的 buffer 的head 元素 pop 出来输出到最终文件中， 然后继续堆排序，继续输出。如果哪个buffer 空了，就去对应的文件中继续补充一部分数据。最终就得到一个全局有序的大文件。&lt;/p&gt;

&lt;p&gt;如果你能想通我上面举的例子，就差不多搞清楚sortshufflewirter的实现原理了，因为解决的是同一个问题。&lt;/p&gt;

&lt;p&gt;SortShuffleWriter 中的处理步骤就是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 PartitionedAppendOnlyMap 或者 PartitionedPairBuffer 在内存中进行排序，  排序的 K 是（partitionId， hash（key）） 这样一个元组。&lt;/li&gt;
  &lt;li&gt;如果超过内存 limit， 我 spill 到一个文件中，这个文件中元素也是有序的，首先是按照 partitionId的排序，如果 partitionId 相同， 再根据 hash（key）进行比较排序&lt;/li&gt;
  &lt;li&gt;如果需要输出全局有序的文件的时候，就需要对之前所有的输出文件 和 当前内存中的数据结构中的数据进行  merge sort， 进行全局排序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和我们开始提的那个问题基本类似，不同的地方在于，需要对 Key 相同的元素进行  aggregation， 就是使用定义的 func 进行聚合， 比如你的算子是 reduceByKey（&lt;em&gt;+&lt;/em&gt;）, 这个func 就是加法运算， 如果两个key 相同， 就会先找到所有相同的key 进行 reduce(&lt;em&gt;+&lt;/em&gt;) 操作，算出一个总结果 Result，然后输出数据（K，Result）元素。&lt;/p&gt;

&lt;p&gt;SortShuffleWriter 中使用 ExternalSorter 来对内存中的数据进行排序，ExternalSorter内部维护了两个集合PartitionedAppendOnlyMap、PartitionedPairBuffer， 两者都是使用了 hash table 数据结构， 如果需要进行 aggregation， 就使用 PartitionedAppendOnlyMap（支持 lookup 某个Key，如果之前存储过相同key的K-V 元素，就需要进行 aggregation，然后再存入aggregation后的 K-V）， 否则使用 PartitionedPairBuffer（只进行添K-V 元素），&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/e8987f6d52e24022dc500e46f7d4dc60&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以看上图， PartitionedAppendOnlyMap 中的 K 是（PatitionId, K）的元组， 这样就是先按照partitionId进行排序，如果 partitionId 相同，再按照  hash（key）再进行排序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/6d013affe760f663204e37a272c49718&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先看下  AppendOnlyMap， 这个很简单就是个 hash table，其中的 K 是（PatitionId, hash（Key））的元组， 当要 put(K, V) 时，先 hash(K) 找存放位置，如果存放位置已经被占用，就使用 Quadratic probing 探测方法来找下一个空闲位置。对于图中的 K6 来说，第三次查找找到 K4 后面的空闲位置，放进去即可。get(K6) 的时候类似，找三次找到 K6，取出紧挨着的 V6，与先来的 value 做 func，结果重新放到 V6 的位置。&lt;/p&gt;

&lt;p&gt;下面看下  ExternalAppendOnlyMap 结构， 这个就是内存中装不下所有元素，就涉及到外部排序，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/2e961b3cf14084b8e9228690ed431c18&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中可以看到整个原理图，逻辑也很简单， 内存不够的时候，先spill了四次，输出到文件中的元素都是有序的，读取的时候都是按序读取，最后跟内存剩余的数据进行 全局merge。&lt;/p&gt;

&lt;p&gt;merge 过程就是 每个文件读取部分数据（StreamBuffer）放到 mergeHeap 里面， 当前内存中的 PartitionedAppendOnlyMap 也进行 sort，形成一个 sortedMap 放在 mergeHeap 里面，  这个 heap 是一个 优先队列 PriorityQueue， 并且自定义了排序方式，就是取出堆元素StreamBuffer的head元素进行比较大小，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样的话，每次从堆顶的 StreamBuffer 中 pop 出的 head 元素就是全局最小的元素（记住是按照（partitionId，hash（Key））排序的）， 如果需要 aggregation， 就把这些key 相同的元素放在一个一个 mergeBuffers 中，  第一个被放入 mergeBuffers 的 StreamBuffer 被称为 minBuffer，那么 minKey 就是 minBuffer 中第一个 record 的 key。当 merge-combine 的时候，与 minKey 有相同的Key的records 被 aggregate 一起，然后输出。&lt;/p&gt;

&lt;p&gt;如果不需要 aggregation， 那就简单了， 直接把 堆顶的 StreamBuffer 中 pop 出的 head 元素 返回就好了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oe9nbfytu.qnssl.com/c/6e5ff58672bcac22e8abbcbb26946ac5&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终读取的时候，从整个 全局 merge 后的读取迭代器中读取的数据，就是按照 partitionId 从小到大排序的数据， 读取过程中使用再按照 分区分段， 并且记录每个分区的文件起始写入位置，把这些位置数据写入索引文件中。&lt;/p&gt;

&lt;h2 id=&quot;shuffle相关参数配置&quot;&gt;Shuffle相关参数配置&lt;/h2&gt;

&lt;p&gt;Shuffle是Spark Core比较复杂的模块，它也是非常影响性能的操作之一。因此，在这里整理了会影响Shuffle性能的各项配置。&lt;/p&gt;

&lt;h3 id=&quot;1sparkshufflemanager&quot;&gt;1．spark.shuffle.manager&lt;/h3&gt;

&lt;p&gt;Spark 1.2.0官方版本支持两种方式的Shuffle，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash Based Shuffle&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Sort Based Shuffle&lt;/code&gt;。其中在Spark 1.0之前仅支持&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash Based Shuffle&lt;/code&gt;。Spark 1.1引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;Sort Based Shuffle&lt;/code&gt;。Spark 1.2的默认Shuffle机制从Hash变成了Sort。如果需要&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash Based Shuffle&lt;/code&gt;，只需将&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.manager&lt;/code&gt;设置成“hash”即可。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​    ① 进入spark安装目录的conf目录&lt;/p&gt;

&lt;p&gt;​    ② &lt;code class=&quot;highlighter-rouge&quot;&gt;cp spark-defaults.conf.template spark-defaults.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    ③ &lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.manager=hash&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;应用场景&lt;/p&gt;

    &lt;p&gt;当产生的临时文件不是很多时，性能可能会比sort shuffle要好。
如果对性能有比较苛刻的要求，那么就要理解这两种不同的Shuffle机制的原理，结合具体的应用场景进行选择。
对于不需要进行排序且Shuffle产生的文件数量不是特别多时，Hash Based Shuffle可能是更好的选择；因为Sort Based Shuffle会按照Reducer的Partition进行排序。
而Sort Based Shuffle的优势就在于可扩展性，它的出现实际上很大程度上是解决Hash Based Shuffle的可扩展性的问题。由于Sort Based Shuffle还在不断地演进中，因此它的性能会得到不断改善。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于选择哪种Shuffle，如果性能要求苛刻，最好还是通过实际测试后再做决定。不过选择默认的Sort，可以满足大部分的场景需要。&lt;/p&gt;

&lt;h3 id=&quot;2sparkshufflespill&quot;&gt;2．spark.shuffle.spill&lt;/h3&gt;

&lt;p&gt;这个参数的默认值是true，用于指定Shuffle过程中如果内存中的数据超过阈值（参考spark.shuffle.memoryFraction的设置）时是否需要将部分数据临时写入外部存储。如果设置为false，那么这个过程就会一直使用内存，会有内存溢出的风险。因此只有在确定内存足够使用时，才可以将这个选项设置为false。&lt;/p&gt;

&lt;h3 id=&quot;3sparkshufflememoryfraction&quot;&gt;3．spark.shuffle.memoryFraction&lt;/h3&gt;

&lt;p&gt;在启用&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.spill&lt;/code&gt;的情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.memoryFraction&lt;/code&gt;决定了当Shuffle过程中使用的&lt;u&gt;内存达到总内存多少比例&lt;/u&gt;的时候开始spill。在Spark 1.2.0里，这个值是0.2。通过这个参数可以设置Shuffle过程占用内存的大小，它直接影响了写入到外部存储的频率和垃圾回收的频率。可以适当调大此值，可以减少磁盘I/O次数。&lt;/p&gt;

&lt;h3 id=&quot;4sparkshufflesortbypassmergethreshold&quot;&gt;4．spark.shuffle.sort.bypassMergeThreshold&lt;/h3&gt;

&lt;p&gt;这个配置的默认值是200，用于设置在Reducer的Partition数目少于多少的时候，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sort Based Shuffle&lt;/code&gt;内部不使用&lt;strong&gt;归并排序&lt;/strong&gt;的方式处理数据，而是直接将每个Partition写入单独的文件。这个方式和&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash Based&lt;/code&gt;的方式类似，区别就是在最后这些文件还是会合并成一个单独的文件，并通过一个Index索引文件来标记不同Partition的位置信息。&lt;/p&gt;

&lt;p&gt;这个可以看作&lt;code class=&quot;highlighter-rouge&quot;&gt;Sort Based Shuffle&lt;/code&gt;在Shuffle量比较小的时候对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash Based Shuffle&lt;/code&gt;的一种折中。当然了它和&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash Based Shuffle&lt;/code&gt;一样，也存在同时打开文件过多导致内存占用增加的问题。因此如果GC比较严重或者内存比较紧张，可以适当降低这个值。&lt;/p&gt;

&lt;h3 id=&quot;5sparkshuffleblocktransferservice&quot;&gt;5．spark.shuffle.blockTransferService&lt;/h3&gt;

&lt;p&gt;在Spark 1.2.0中这个配置的默认值是netty，而在之前的版本中是nio。它主要是用于在各个Executor之间传输Shuffle数据。netty的实现更加简洁，但实际上用户不用太关心这个选项。除非有特殊需求，否则采用默认配置即可。&lt;/p&gt;

&lt;h3 id=&quot;6sparkshuffleconsolidatefiles&quot;&gt;6．spark.shuffle.consolidateFiles&lt;/h3&gt;

&lt;p&gt;这个配置的默认值是false。主要是为了解决在&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash Based Shuffle&lt;/code&gt;过程中产生过多文件的问题。如果配置选项为true，那么对于同一个Core上运行的Shuffle Map Task不会产生一个新的Shuffle文件而是重用原来的。&lt;/p&gt;

&lt;p&gt;但是consolidateFiles的机制在Spark 0.8.1就引入了，到Spark 1.2.0还是没有稳定下来。从源码实现的角度看，实现源码是非常简单的，但是由于涉及本地文件系统等限制，这个策略可能会带来各种各样的问题。一般不建议开启。&lt;/p&gt;

&lt;h3 id=&quot;7sparkshufflecompress和sparkshufflespillcompress&quot;&gt;7．spark.shuffle.compress和spark.shuffle.spill.compress&lt;/h3&gt;

&lt;p&gt;这两个参数的默认配置都是true。&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.compress&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.spill.compress&lt;/code&gt;都是用来设置Shuffle过程中是否对Shuffle数据进行压缩。其中，前者针对最终写入本地文件系统的输出文件；后者针对在处理过程需要写入到外部存储的中间数据，即针对最终的shuffle输出文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.compress&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;需要评估压缩解压时间带来的时间消耗和因为数据压缩带来的时间节省。如果网络成为瓶颈，比如集群普遍使用的是千兆网络，那么将这个选项设置为true可能更合理；如果计算是CPU密集型的，那么将这个选项设置为false可能更好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;spark.shuffle.spill.compress&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;如果设置为true，代表处理的中间结果在spill到本地硬盘时都会进行压缩，在将中间结果取回进行merge的时候，要进行解压。因此要综合考虑CPU由于引入压缩、解压的消耗时间和Disk IO因为压缩带来的节省时间的比较。在Disk IO成为瓶颈的场景下，设置为true可能比较合适；如果本地硬盘是SSD，那么设置为false可能比较合适。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8sparkreducermaxmbinflight&quot;&gt;8．spark.reducer.maxMbInFlight&lt;/h3&gt;

&lt;p&gt;这个参数用于限制一个Reducer Task向其他的Executor请求Shuffle数据时所占用的最大内存数，尤其是如果网卡是千兆和千兆以下的网卡时。默认值是 设置这个值需要综合考虑网卡带宽和内存。&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spark-Shuffle/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spark-Shuffle/</guid>
        
        <category>Spark</category>
        
        <category>Programing</category>
        
        <category>BigData</category>
        
        
      </item>
    
      <item>
        <title>Hive保留关键字冲突的解决</title>
        <description>&lt;p&gt;最近做Hive表创建的时遇到一个问题.&lt;/p&gt;

&lt;p&gt;报错如下:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;FailedPredicateException&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;identifier,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;useSQL11ReservedKeywordsForIdentifier&lt;span class=&quot;o&quot;&gt;()}&lt;/span&gt;?&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后在&lt;a href=&quot;https://community.hortonworks.com/questions/21626/where-should-i-add-hivesupportsql11reservedkeyword.html&quot;&gt;HCC&lt;/a&gt;上找到了对应的解决办法.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;-- 解决办法很简单, 就是直接修改一下Hive的配置&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keywords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BTW, 顺便吐槽一下, 百度吃枣药丸, 因为公司用不了谷歌, 没办法去百度找了好几页结果都没有结果. 然后用了bing, 第四条就发现了答案…&lt;/p&gt;

</description>
        <pubDate>Fri, 26 Jul 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/07/26/Hive%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/07/26/Hive%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</guid>
        
        <category>Hive</category>
        
        <category>Tricks</category>
        
        <category>Programing</category>
        
        <category>Debug</category>
        
        
      </item>
    
      <item>
        <title>剑指Offer-计算机网络</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;1-计算机网络体系结构&quot;&gt;1. 计算机网络体系结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-五层协议&quot;&gt;1.1 五层协议&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt; ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;传输层&lt;/strong&gt; ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：&lt;strong&gt;传输控制协议 TCP&lt;/strong&gt;，提供面向连接、可靠的数据传输服务，数据单位为报文段；&lt;strong&gt;用户数据报协议 UDP&lt;/strong&gt;，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;网络层&lt;/strong&gt; ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;物理层&lt;/strong&gt; ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-osi&quot;&gt;1.2. OSI&lt;/h3&gt;

&lt;p&gt;其中表示层和会话层用途如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;表示层&lt;/strong&gt; ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;会话层&lt;/strong&gt; ：建立及管理会话。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。&lt;/p&gt;

&lt;h3 id=&quot;13-tcpip&quot;&gt;1.3. TCP/IP&lt;/h3&gt;

&lt;p&gt;它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。&lt;/p&gt;

&lt;p&gt;TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;14-数据在各层之间的传递过程&quot;&gt;1.4 数据在各层之间的传递过程&lt;/h3&gt;

&lt;p&gt;在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。&lt;/p&gt;

&lt;p&gt;路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。&lt;/p&gt;

&lt;h2 id=&quot;2-http&quot;&gt;2. HTTP&lt;/h2&gt;

&lt;h3 id=&quot;21-基础概念&quot;&gt;2.1 基础概念&lt;/h3&gt;

&lt;h4 id=&quot;211-uri&quot;&gt;2.1.1 URI&lt;/h4&gt;

&lt;p&gt;URI 包含 URL 和 URN。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png&quot; width=&quot;550&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;212-请求和响应报文&quot;&gt;2.1.2 请求和响应报文&lt;/h4&gt;

&lt;h5 id=&quot;2121-请求报文&quot;&gt;2.1.2.1 请求报文&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_RequestMessageExample.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;2122-响应报文&quot;&gt;2.1.2.2 响应报文&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_ResponseMessageExample.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-http-方法&quot;&gt;2.2 HTTP 方法&lt;/h3&gt;

&lt;p&gt;客户端发送的 &lt;strong&gt;请求报文&lt;/strong&gt; 第一行为请求行，包含了方法字段。&lt;/p&gt;

&lt;h4 id=&quot;221-get&quot;&gt;2.2.1 GET&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;获取资源&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当前网络请求中，绝大部分使用的是 GET 方法。&lt;/p&gt;

&lt;h4 id=&quot;222-head&quot;&gt;2.2.2 HEAD&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;获取报文首部&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;和 GET 方法类似，但是不返回报文实体主体部分。&lt;/p&gt;

&lt;p&gt;主要用于确认 URL 的有效性以及资源更新的日期时间等。&lt;/p&gt;

&lt;h4 id=&quot;223-post&quot;&gt;2.2.3 POST&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;传输实体主体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;POST 主要用来传输数据，而 GET 主要用来获取资源。&lt;/p&gt;

&lt;p&gt;更多 POST 与 GET 的比较请见第九章。&lt;/p&gt;

&lt;h4 id=&quot;223-put&quot;&gt;2.2.3 PUT&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;上传文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;New File&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;224-patch&quot;&gt;2.2.4 PATCH&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;对资源进行部分修改&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: &quot;e0023aa4e&quot;
Content-Length: 100

[description of changes]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;225-delete&quot;&gt;2.2.5 DELETE&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;删除文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与 PUT 功能相反，并且同样不带验证机制。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;DELETE /file.html HTTP/1.1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;226-options&quot;&gt;2.2.6 OPTIONS&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;查询支持的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查询指定的 URL 能够支持的方法。&lt;/p&gt;

&lt;p&gt;会返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;Allow: GET, POST, HEAD, OPTIONS&lt;/code&gt; 这样的内容。&lt;/p&gt;

&lt;h4 id=&quot;227-connect&quot;&gt;2.2.7 CONNECT&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;要求在与代理服务器通信时建立隧道&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;CONNECT www.example.com:443 HTTP/1.1Copy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;229-trace&quot;&gt;2.2.9 TRACE&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;追踪路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;服务器会将通信路径返回给客户端。&lt;/p&gt;

&lt;p&gt;发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。&lt;/p&gt;

&lt;p&gt;通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。&lt;/p&gt;

&lt;h3 id=&quot;23-http-状态码&quot;&gt;2.3 HTTP 状态码&lt;/h3&gt;

&lt;p&gt;服务器返回的 &lt;strong&gt;响应报文&lt;/strong&gt; 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;状态码&lt;/th&gt;
      &lt;th&gt;类别&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1XX&lt;/td&gt;
      &lt;td&gt;Informational（信息性状态码）&lt;/td&gt;
      &lt;td&gt;接收的请求正在处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2XX&lt;/td&gt;
      &lt;td&gt;Success（成功状态码）&lt;/td&gt;
      &lt;td&gt;请求正常处理完毕&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3XX&lt;/td&gt;
      &lt;td&gt;Redirection（重定向状态码）&lt;/td&gt;
      &lt;td&gt;需要进行附加操作以完成请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4XX&lt;/td&gt;
      &lt;td&gt;Client Error（客户端错误状态码）&lt;/td&gt;
      &lt;td&gt;服务器无法处理请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5XX&lt;/td&gt;
      &lt;td&gt;Server Error（服务器错误状态码）&lt;/td&gt;
      &lt;td&gt;服务器处理请求出错&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;231-1xx-信息&quot;&gt;2.3.1 1XX 信息&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;100 Continue&lt;/strong&gt; ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;232-2xx-成功&quot;&gt;2.3.2 2XX 成功&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;200 OK&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;204 No Content&lt;/strong&gt; ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;206 Partial Content&lt;/strong&gt; ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;233-3xx-重定向&quot;&gt;2.3.3 3XX 重定向&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt; ：永久性重定向&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;302 Found&lt;/strong&gt; ：临时性重定向&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;303 See Other&lt;/strong&gt; ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。&lt;/li&gt;
  &lt;li&gt;注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt; ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;307 Temporary Redirect&lt;/strong&gt; ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;234-4xx-客户端错误&quot;&gt;2.3.4 4XX 客户端错误&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt; ：请求报文中存在语法错误。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;401 Unauthorized&lt;/strong&gt; ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;403 Forbidden&lt;/strong&gt; ：请求被拒绝。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;235-5xx-服务器错误&quot;&gt;2.3.5 5XX 服务器错误&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt; ：服务器正在执行请求时发生错误。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt; ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;24-http-首部&quot;&gt;2.4 HTTP 首部&lt;/h3&gt;

&lt;p&gt;有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。&lt;/p&gt;

&lt;p&gt;各种首部字段及其含义如下（不需要全记，仅供查阅）：&lt;/p&gt;

&lt;h4 id=&quot;241-通用首部字段&quot;&gt;2.4.1 通用首部字段&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;首部字段名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Cache-Control&lt;/td&gt;
      &lt;td&gt;控制缓存的行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Connection&lt;/td&gt;
      &lt;td&gt;控制不再转发给代理的首部字段、管理持久连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Date&lt;/td&gt;
      &lt;td&gt;创建报文的日期时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Pragma&lt;/td&gt;
      &lt;td&gt;报文指令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Trailer&lt;/td&gt;
      &lt;td&gt;报文末端的首部一览&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Transfer-Encoding&lt;/td&gt;
      &lt;td&gt;指定报文主体的传输编码方式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Upgrade&lt;/td&gt;
      &lt;td&gt;升级为其他协议&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Via&lt;/td&gt;
      &lt;td&gt;代理服务器的相关信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Warning&lt;/td&gt;
      &lt;td&gt;错误通知&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;242-请求首部字段&quot;&gt;2.4.2 请求首部字段&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;首部字段名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Accept&lt;/td&gt;
      &lt;td&gt;用户代理可处理的媒体类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Accept-Charset&lt;/td&gt;
      &lt;td&gt;优先的字符集&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Accept-Encoding&lt;/td&gt;
      &lt;td&gt;优先的内容编码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Accept-Language&lt;/td&gt;
      &lt;td&gt;优先的语言（自然语言）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Authorization&lt;/td&gt;
      &lt;td&gt;Web 认证信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Expect&lt;/td&gt;
      &lt;td&gt;期待服务器的特定行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;From&lt;/td&gt;
      &lt;td&gt;用户的电子邮箱地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Host&lt;/td&gt;
      &lt;td&gt;请求资源所在服务器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;If-Match&lt;/td&gt;
      &lt;td&gt;比较实体标记（ETag）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;If-Modified-Since&lt;/td&gt;
      &lt;td&gt;比较资源的更新时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;If-None-Match&lt;/td&gt;
      &lt;td&gt;比较实体标记（与 If-Match 相反）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;If-Range&lt;/td&gt;
      &lt;td&gt;资源未更新时发送实体 Byte 的范围请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;If-Unmodified-Since&lt;/td&gt;
      &lt;td&gt;比较资源的更新时间（与 If-Modified-Since 相反）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Max-Forwards&lt;/td&gt;
      &lt;td&gt;最大传输逐跳数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Proxy-Authorization&lt;/td&gt;
      &lt;td&gt;代理服务器要求客户端的认证信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Range&lt;/td&gt;
      &lt;td&gt;实体的字节范围请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Referer&lt;/td&gt;
      &lt;td&gt;对请求中 URI 的原始获取方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TE&lt;/td&gt;
      &lt;td&gt;传输编码的优先级&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;User-Agent&lt;/td&gt;
      &lt;td&gt;HTTP 客户端程序的信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;243-响应首部字段&quot;&gt;2.4.3 响应首部字段&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;首部字段名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Accept-Ranges&lt;/td&gt;
      &lt;td&gt;是否接受字节范围请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Age&lt;/td&gt;
      &lt;td&gt;推算资源创建经过时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ETag&lt;/td&gt;
      &lt;td&gt;资源的匹配信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Location&lt;/td&gt;
      &lt;td&gt;令客户端重定向至指定 URI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Proxy-Authenticate&lt;/td&gt;
      &lt;td&gt;代理服务器对客户端的认证信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Retry-After&lt;/td&gt;
      &lt;td&gt;对再次发起请求的时机要求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Server&lt;/td&gt;
      &lt;td&gt;HTTP 服务器的安装信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Vary&lt;/td&gt;
      &lt;td&gt;代理服务器缓存的管理信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WWW-Authenticate&lt;/td&gt;
      &lt;td&gt;服务器对客户端的认证信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;244-实体首部字段&quot;&gt;2.4.4 实体首部字段&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;首部字段名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Allow&lt;/td&gt;
      &lt;td&gt;资源可支持的 HTTP 方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content-Encoding&lt;/td&gt;
      &lt;td&gt;实体主体适用的编码方式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content-Language&lt;/td&gt;
      &lt;td&gt;实体主体的自然语言&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content-Length&lt;/td&gt;
      &lt;td&gt;实体主体的大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content-Location&lt;/td&gt;
      &lt;td&gt;替代对应资源的 URI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content-MD5&lt;/td&gt;
      &lt;td&gt;实体主体的报文摘要&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content-Range&lt;/td&gt;
      &lt;td&gt;实体主体的位置范围&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content-Type&lt;/td&gt;
      &lt;td&gt;实体主体的媒体类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Expires&lt;/td&gt;
      &lt;td&gt;实体主体过期的日期时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Last-Modified&lt;/td&gt;
      &lt;td&gt;资源的最后修改日期时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;25-具体应用&quot;&gt;2.5 具体应用&lt;/h3&gt;

&lt;h4 id=&quot;251-连接管理&quot;&gt;2.5.1 连接管理&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;2511-短连接与长连接&quot;&gt;2.5.1.1 短连接与长连接&lt;/h5&gt;

&lt;p&gt;当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。&lt;/p&gt;

&lt;p&gt;长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Connection : close&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Connection : Keep-Alive&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2512-流水线&quot;&gt;2.5.1.2 流水线&lt;/h5&gt;

&lt;p&gt;默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。&lt;/p&gt;

&lt;p&gt;流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。&lt;/p&gt;

&lt;h4 id=&quot;252-cookie&quot;&gt;2.5.2 Cookie&lt;/h4&gt;

&lt;p&gt;HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。&lt;/p&gt;

&lt;p&gt;Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。&lt;/p&gt;

&lt;p&gt;Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。&lt;/p&gt;

&lt;h4 id=&quot;2521-用途&quot;&gt;2.5.2.1 用途&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）&lt;/li&gt;
  &lt;li&gt;个性化设置（如用户自定义设置、主题等）&lt;/li&gt;
  &lt;li&gt;浏览器行为跟踪（如跟踪分析用户行为等）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2522-创建过程&quot;&gt;2.5.2.2 创建过程&lt;/h5&gt;

&lt;p&gt;服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-pseudocode&quot;&gt;HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2523-分类&quot;&gt;2.5.2.3 分类&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。&lt;/li&gt;
  &lt;li&gt;持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2524-作用域&quot;&gt;2.5.2.4 作用域&lt;/h5&gt;

&lt;p&gt;Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。&lt;/p&gt;

&lt;p&gt;Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/”) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/docs&lt;/li&gt;
  &lt;li&gt;/docs/Web/&lt;/li&gt;
  &lt;li&gt;/docs/Web/HTTP&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2525--javascript&quot;&gt;2.5.2.5  JavaScript&lt;/h5&gt;

&lt;p&gt;浏览器通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;document.cookie&lt;/code&gt; 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cookie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;yummy_cookie=choco&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cookie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;tasty_cookie=strawberry&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cookie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2526-httponly&quot;&gt;2.5.2.6 HttpOnly&lt;/h5&gt;

&lt;p&gt;标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;document.cookie&lt;/code&gt; API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。&lt;/p&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2527-secure&quot;&gt;2.5.2.7 Secure&lt;/h5&gt;

&lt;p&gt;标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。&lt;/p&gt;

&lt;h5 id=&quot;2528-session&quot;&gt;2.5.2.8 Session&lt;/h5&gt;

&lt;p&gt;除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。&lt;/p&gt;

&lt;p&gt;Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。&lt;/p&gt;

&lt;p&gt;使用 Session 维护用户登录状态的过程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；&lt;/li&gt;
  &lt;li&gt;服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；&lt;/li&gt;
  &lt;li&gt;服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；&lt;/li&gt;
  &lt;li&gt;客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。&lt;/p&gt;

&lt;h5 id=&quot;2529-浏览器禁用-cookie&quot;&gt;2.5.2.9 浏览器禁用 Cookie&lt;/h5&gt;

&lt;p&gt;此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。&lt;/p&gt;

&lt;h5 id=&quot;25210-cookie-与-session-选择&quot;&gt;2.5.2.10 Cookie 与 Session 选择&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；&lt;/li&gt;
  &lt;li&gt;Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；&lt;/li&gt;
  &lt;li&gt;对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;253-缓存&quot;&gt;2.5.3 缓存&lt;/h4&gt;

&lt;h5 id=&quot;2531-优点&quot;&gt;2.5.3.1 优点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;缓解服务器压力；&lt;/li&gt;
  &lt;li&gt;降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2532-实现方法&quot;&gt;2.5.3.2 实现方法&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;让代理服务器进行缓存；&lt;/li&gt;
  &lt;li&gt;让客户端浏览器进行缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2533-cache-control&quot;&gt;2.5.3.3 Cache-Control&lt;/h5&gt;

&lt;p&gt;HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。&lt;/p&gt;

&lt;h6 id=&quot;25331-禁止进行缓存&quot;&gt;2.5.3.3.1 禁止进行缓存&lt;/h6&gt;

&lt;p&gt;no-store 指令规定不能对请求或响应的任何一部分进行缓存。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Cache-Control: no-storeCopy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;25332-强制确认缓存&quot;&gt;2.5.3.3.2 强制确认缓存&lt;/h6&gt;

&lt;p&gt;no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Cache-Control: no-cacheCopy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;25333-私有缓存和公共缓存&quot;&gt;2.5.3.3.3 私有缓存和公共缓存&lt;/h6&gt;

&lt;p&gt;private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Cache-Control: privateCopy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Cache-Control: publicCopy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;25334-缓存过期机制&quot;&gt;2.5.3.3.4 缓存过期机制&lt;/h6&gt;

&lt;p&gt;max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。&lt;/p&gt;

&lt;p&gt;max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Cache-Control: max-age=31536000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Expires: Wed, 04 Jul 2012 08:26:05 GMT
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在 HTTP/1.1 中，会优先处理 max-age 指令；&lt;/li&gt;
  &lt;li&gt;在 HTTP/1.0 中，max-age 指令会被忽略掉。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2534-缓存验证&quot;&gt;2.5.3.4 缓存验证&lt;/h5&gt;

&lt;p&gt;需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.google.com/&lt;/code&gt; 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;ETag: &quot;82e22293907ce725faf67773957acd12&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;254-内容协商&quot;&gt;2.5.4 内容协商&lt;/h4&gt;

&lt;p&gt;通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。&lt;/p&gt;

&lt;h5 id=&quot;2541-类型&quot;&gt;2.5.4.1 类型&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;2.5.4.1.1 服务端驱动型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。&lt;/p&gt;

&lt;p&gt;它存在以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器很难知道客户端浏览器的全部信息；&lt;/li&gt;
  &lt;li&gt;客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；&lt;/li&gt;
  &lt;li&gt;给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.5.4.1.2 代理驱动型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。&lt;/p&gt;

&lt;h5 id=&quot;2542-vary&quot;&gt;2.5.4.2 Vary&lt;/h5&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Vary: Accept-Language
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。&lt;/p&gt;

&lt;p&gt;例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vary: Accept-Language&lt;/code&gt; 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。&lt;/p&gt;

&lt;h4 id=&quot;255-内容编码&quot;&gt;2.5.5 内容编码&lt;/h4&gt;

&lt;p&gt;内容编码将实体主体进行压缩，从而减少传输的数据量。&lt;/p&gt;

&lt;p&gt;常用的内容编码有：gzip、compress、deflate、identity。&lt;/p&gt;

&lt;p&gt;浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。&lt;/p&gt;

&lt;h4 id=&quot;256-范围请求&quot;&gt;2.5.6 范围请求&lt;/h4&gt;

&lt;p&gt;如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。&lt;/p&gt;

&lt;h5 id=&quot;2561-range&quot;&gt;2.5.6.1 Range&lt;/h5&gt;

&lt;p&gt;在请求报文中添加 Range 首部字段指定请求的范围。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请求成功的话服务器返回的响应包含 206 Partial Content 状态码。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2562-accept-ranges&quot;&gt;2.5.6.2 Accept-Ranges&lt;/h5&gt;

&lt;p&gt;响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Accept-Ranges: bytesCopy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2563-响应状态码&quot;&gt;2.5.6.3 响应状态码&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;在请求成功的情况下，服务器会返回 206 Partial Content 状态码。&lt;/li&gt;
  &lt;li&gt;在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。&lt;/li&gt;
  &lt;li&gt;在不支持范围请求的情况下，服务器会返回 200 OK 状态码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;257-分块传输编码&quot;&gt;2.5.7 分块传输编码&lt;/h4&gt;

&lt;p&gt;Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。&lt;/p&gt;

&lt;h4 id=&quot;258-多部分对象集合&quot;&gt;2.5.8 多部分对象集合&lt;/h4&gt;

&lt;p&gt;一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。&lt;/p&gt;

&lt;p&gt;例如，上传多个表单时可以使用如下方式：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name=&quot;submit-name&quot;

Larry
--AaB03x
Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;259-虚拟主机&quot;&gt;2.5.9 虚拟主机&lt;/h4&gt;

&lt;p&gt;HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。&lt;/p&gt;

&lt;h4 id=&quot;2510-通信数据转发&quot;&gt;2.5.10 通信数据转发&lt;/h4&gt;

&lt;h5 id=&quot;25101-代理&quot;&gt;2.5.10.1 代理&lt;/h5&gt;

&lt;p&gt;代理服务器接受客户端的请求，并且转发给其它服务器。&lt;/p&gt;

&lt;p&gt;使用代理的主要目的是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缓存&lt;/li&gt;
  &lt;li&gt;负载均衡&lt;/li&gt;
  &lt;li&gt;网络访问控制&lt;/li&gt;
  &lt;li&gt;访问日志记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代理服务器分为正向代理和反向代理两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户察觉得到正向代理的存在。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;而反向代理一般位于内部网络中，用户察觉不到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;25102-网关&quot;&gt;2.5.10.2 网关&lt;/h5&gt;

&lt;p&gt;与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。&lt;/p&gt;

&lt;h5 id=&quot;25103-隧道&quot;&gt;2.5.10.3 隧道&lt;/h5&gt;

&lt;p&gt;使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。&lt;/p&gt;

&lt;h3 id=&quot;26-https&quot;&gt;2.6 HTTPS&lt;/h3&gt;

&lt;p&gt;HTTP 有以下安全性问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用明文进行通信，内容可能会被窃听；&lt;/li&gt;
  &lt;li&gt;不验证通信方的身份，通信方的身份有可能遭遇伪装；&lt;/li&gt;
  &lt;li&gt;无法证明报文的完整性，报文有可能遭篡改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。&lt;/p&gt;

&lt;p&gt;通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;261-加密&quot;&gt;2.6.1 加密&lt;/h4&gt;

&lt;h5 id=&quot;2611-对称密钥加密&quot;&gt;2.6.1.1 对称密钥加密&lt;/h5&gt;

&lt;p&gt;对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：运算速度快；&lt;/li&gt;
  &lt;li&gt;缺点：无法安全地将密钥传输给通信方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;2612-非对称密钥加密&quot;&gt;2.6.1.2 非对称密钥加密&lt;/h5&gt;

&lt;p&gt;非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。&lt;/p&gt;

&lt;p&gt;公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。&lt;/p&gt;

&lt;p&gt;非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：可以更安全地将公开密钥传输给通信发送方；&lt;/li&gt;
  &lt;li&gt;缺点：运算速度慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;2613-https-采用的加密方式&quot;&gt;2.6.1.3 HTTPS 采用的加密方式&lt;/h5&gt;

&lt;p&gt;HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;262-认证&quot;&gt;2.6.2 认证&lt;/h4&gt;

&lt;p&gt;通过使用 &lt;strong&gt;证书&lt;/strong&gt; 来对通信方进行认证。&lt;/p&gt;

&lt;p&gt;数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。&lt;/p&gt;

&lt;p&gt;服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。&lt;/p&gt;

&lt;p&gt;进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;263-完整性保护&quot;&gt;2.6.3 完整性保护&lt;/h4&gt;

&lt;p&gt;SSL 提供报文摘要功能来进行完整性保护。&lt;/p&gt;

&lt;p&gt;HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。&lt;/p&gt;

&lt;p&gt;HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。&lt;/p&gt;

&lt;h4 id=&quot;264-https-的缺点&quot;&gt;2.6.4 HTTPS 的缺点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;因为需要进行加密解密等过程，因此速度会更慢；&lt;/li&gt;
  &lt;li&gt;需要支付证书授权的高额费用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;27-http20&quot;&gt;2.7 HTTP/2.0&lt;/h3&gt;

&lt;h4 id=&quot;271-http1x-缺陷&quot;&gt;2.7.1 HTTP/1.x 缺陷&lt;/h4&gt;

&lt;p&gt;HTTP/1.x 实现简单是以牺牲性能为代价的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端需要使用多个连接才能实现并发和缩短延迟；&lt;/li&gt;
  &lt;li&gt;不会压缩请求和响应首部，从而导致不必要的网络流量；&lt;/li&gt;
  &lt;li&gt;不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;272-二进制分帧层&quot;&gt;2.7.2 二进制分帧层&lt;/h4&gt;

&lt;p&gt;HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。&lt;/li&gt;
  &lt;li&gt;消息（Message）是与逻辑请求或响应对应的完整的一系列帧。&lt;/li&gt;
  &lt;li&gt;帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png&quot; width=&quot;650&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;273-服务端推送&quot;&gt;2.7.3 服务端推送&lt;/h4&gt;

&lt;p&gt;HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;274-首部压缩&quot;&gt;2.7.4 首部压缩&lt;/h4&gt;

&lt;p&gt;HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。&lt;/p&gt;

&lt;p&gt;HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。&lt;/p&gt;

&lt;p&gt;不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png&quot; width=&quot;650&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;28-http11-新特性&quot;&gt;2.8 HTTP/1.1 新特性&lt;/h3&gt;

&lt;p&gt;详细内容请见上文&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认是长连接&lt;/li&gt;
  &lt;li&gt;支持流水线&lt;/li&gt;
  &lt;li&gt;支持同时打开多个 TCP 连接&lt;/li&gt;
  &lt;li&gt;支持虚拟主机&lt;/li&gt;
  &lt;li&gt;新增状态码 100&lt;/li&gt;
  &lt;li&gt;支持分块传输编码&lt;/li&gt;
  &lt;li&gt;新增缓存处理指令 max-age&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;29-get-和-post-比较&quot;&gt;2.9 GET 和 POST 比较&lt;/h3&gt;

&lt;h4 id=&quot;291-作用&quot;&gt;2.9.1 作用&lt;/h4&gt;

&lt;p&gt;GET 用于获取资源，而 POST 用于传输实体主体。&lt;/p&gt;

&lt;h4 id=&quot;292-参数&quot;&gt;2.9.2 参数&lt;/h4&gt;

&lt;p&gt;GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。&lt;/p&gt;

&lt;p&gt;因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;中文&lt;/code&gt; 会转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;%E4%B8%AD%E6%96%87&lt;/code&gt;，而空格会转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;%20&lt;/code&gt;。POST 参数支持标准字符集。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET /test/demo_form.asp?name1=value1&amp;amp;name2=value2 HTTP/1.1Copy to clipboardErrorCopied
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;amp;name2=value2Copy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;293-安全&quot;&gt;2.9.3 安全&lt;/h4&gt;

&lt;p&gt;安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。&lt;/p&gt;

&lt;p&gt;GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。&lt;/p&gt;

&lt;p&gt;安全的方法除了 GET 之外还有：HEAD、OPTIONS。&lt;/p&gt;

&lt;p&gt;不安全的方法除了 POST 之外还有 PUT、DELETE。&lt;/p&gt;

&lt;h4 id=&quot;294-幂等性&quot;&gt;2.9.4 幂等性&lt;/h4&gt;

&lt;p&gt;幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。&lt;/p&gt;

&lt;p&gt;所有的安全方法也都是幂等的。&lt;/p&gt;

&lt;p&gt;在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。&lt;/p&gt;

&lt;p&gt;GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1Copy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;POST /add_row HTTP/1.1   -&amp;gt; Adds a 1nd row
POST /add_row HTTP/1.1   -&amp;gt; Adds a 2nd row
POST /add_row HTTP/1.1   -&amp;gt; Adds a 3rd rowCopy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 404Copy to clipboardErrorCopied
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;295-可缓存&quot;&gt;2.9.5 可缓存&lt;/h4&gt;

&lt;p&gt;如果要对响应进行缓存，需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。&lt;/li&gt;
  &lt;li&gt;响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。&lt;/li&gt;
  &lt;li&gt;响应报文的 Cache-Control 首部字段没有指定不进行缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;296-xmlhttprequest&quot;&gt;2.9.6 XMLHttpRequest&lt;/h4&gt;

&lt;p&gt;为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。&lt;/li&gt;
  &lt;li&gt;而 GET 方法 Header 和 Data 会一起发送。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-socket&quot;&gt;3. Socket&lt;/h2&gt;

&lt;h3 id=&quot;31-io-模型&quot;&gt;3.1 I/O 模型&lt;/h3&gt;

&lt;p&gt;一个输入操作通常包括两个阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;等待数据准备好&lt;/li&gt;
  &lt;li&gt;从内核向进程复制数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。&lt;/p&gt;

&lt;p&gt;Unix 有五种 I/O 模型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;阻塞式 I/O&lt;/li&gt;
  &lt;li&gt;非阻塞式 I/O&lt;/li&gt;
  &lt;li&gt;I/O 复用（select 和 poll）&lt;/li&gt;
  &lt;li&gt;信号驱动式 I/O（SIGIO）&lt;/li&gt;
  &lt;li&gt;异步 I/O（AIO）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;311-阻塞式-io&quot;&gt;3.1.1 阻塞式 I/O&lt;/h4&gt;

&lt;p&gt;应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。&lt;/p&gt;

&lt;p&gt;应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。&lt;/p&gt;

&lt;p&gt;下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;recvfrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addrlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clipboardErrorCopied&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928416812_4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;312-非阻塞式-io&quot;&gt;3.1.2 非阻塞式 I/O&lt;/h4&gt;

&lt;p&gt;应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。&lt;/p&gt;

&lt;p&gt;由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929000361_5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;313-io-复用&quot;&gt;3.1.3 I/O 复用&lt;/h4&gt;

&lt;p&gt;使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。&lt;/p&gt;

&lt;p&gt;它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。&lt;/p&gt;

&lt;p&gt;如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929444818_6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;314-信号驱动-io&quot;&gt;3.1.4 信号驱动 I/O&lt;/h4&gt;

&lt;p&gt;应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。&lt;/p&gt;

&lt;p&gt;相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929553651_7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;315-异步-io&quot;&gt;3.1.5 异步 I/O&lt;/h4&gt;

&lt;p&gt;应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。&lt;/p&gt;

&lt;p&gt;异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492930243286_8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;316-五大-io-模型比较&quot;&gt;3.1.6 五大 I/O 模型比较&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。&lt;/li&gt;
  &lt;li&gt;异步 I/O：第二阶段应用进程不会阻塞。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。&lt;/p&gt;

&lt;p&gt;非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928105791_3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-io-复用&quot;&gt;3.2 I/O 复用&lt;/h3&gt;

&lt;p&gt;select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。&lt;/p&gt;

&lt;h4 id=&quot;select&quot;&gt;select&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writefds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exceptfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。&lt;/li&gt;
  &lt;li&gt;timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。&lt;/li&gt;
  &lt;li&gt;成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Reset the sets&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FD_ZERO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FD_ZERO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_out&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Monitor sock1 for input events&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FD_SET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Monitor sock2 for output events&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FD_SET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_out&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Find out which socket has the largest numeric value as select requires it&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largest_sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Wait up to 10 seconds&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_usec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Call the select&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largest_sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Check if select actually succeed&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// report error and abort&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// timeout; no event detected&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FD_ISSET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// input event on sock1&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FD_ISSET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_out&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// output event on sock2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clipboardErrorCopied&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;poll&quot;&gt;poll&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clipboardErrorCopied&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。&lt;/p&gt;

&lt;p&gt;poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollfd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;cm&quot;&gt;/* file descriptor */&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* requested events */&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;revents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* returned events */&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clipboardErrorCopied&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The structure for two events&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollfd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Monitor sock1 for input&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Monitor sock2 for output&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POLLOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Wait 10 seconds&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Check if poll actually succeed&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// report error and abort&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// timeout; no event detected&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// If we detect the event, zero it out so we can reuse the structure&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POLLIN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// input event on sock1&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POLLOUT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// output event on sock2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;比较&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=比较&quot;&gt;比较&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1-功能&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-功能&quot;&gt;1. 功能&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;select 会修改描述符，而 poll 不会；&lt;/li&gt;
  &lt;li&gt;select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；&lt;/li&gt;
  &lt;li&gt;poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。&lt;/li&gt;
  &lt;li&gt;如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-速度&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-速度&quot;&gt;2. 速度&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。&lt;/p&gt;

&lt;h3 id=&quot;3-可移植性&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-可移植性&quot;&gt;3. 可移植性&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。&lt;/p&gt;

&lt;h2 id=&quot;epoll&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=epoll&quot;&gt;epoll&lt;/a&gt;&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;epoll_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clipboardErrorCopied&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。&lt;/p&gt;

&lt;p&gt;从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。&lt;/p&gt;

&lt;p&gt;epoll 仅适用于 Linux OS。&lt;/p&gt;

&lt;p&gt;epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。&lt;/p&gt;

&lt;p&gt;epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The function argument is ignored (it was not before, but now it is), so put your favorite number here&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollingfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xCAFE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollingfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// report error&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Initialize the epoll structure in case more members are added in future&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Associate the connection class instance with the event. You can associate anything&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// you want, epoll does not use this information. We store a connection class pointer, pConnection1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pConnection1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Monitor for input, and do not automatically rearm the descriptor after the event&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EPOLLONESHOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Add the descriptor into the monitoring list. We can do it even if another thread is&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// waiting in epoll_wait - the descriptor will be properly added&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EPOLL_CTL_ADD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pConnection1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getSocket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// report error&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollingfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Check if epoll actually succeed&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// report error and abort&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// timeout; no event detected&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Check if any events detected&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Get back our connection pointer&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Connection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handleReadEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clipboardErrorCopied&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;工作模式&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=工作模式&quot;&gt;工作模式&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。&lt;/p&gt;

&lt;h3 id=&quot;1-lt-模式&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-lt-模式&quot;&gt;1. LT 模式&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。&lt;/p&gt;

&lt;h3 id=&quot;2-et-模式&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-et-模式&quot;&gt;2. ET 模式&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。&lt;/p&gt;

&lt;p&gt;很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。&lt;/p&gt;

&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=应用场景&quot;&gt;应用场景&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。&lt;/p&gt;

&lt;h3 id=&quot;1-select-应用场景&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-select-应用场景&quot;&gt;1. select 应用场景&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。&lt;/p&gt;

&lt;p&gt;select 可移植性更好，几乎被所有主流平台所支持。&lt;/p&gt;

&lt;h3 id=&quot;2-poll-应用场景&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-poll-应用场景&quot;&gt;2. poll 应用场景&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。&lt;/p&gt;

&lt;h3 id=&quot;3-epoll-应用场景&quot;&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-epoll-应用场景&quot;&gt;3. epoll 应用场景&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。&lt;/p&gt;

&lt;p&gt;需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。&lt;/p&gt;

&lt;p&gt;需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Jul 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/07/23/%E5%89%91%E6%8C%87Offer_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/07/23/%E5%89%91%E6%8C%87Offer_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
        
        <category>JobHunting</category>
        
        <category>Foundations</category>
        
        <category>OperatingSystem</category>
        
        
      </item>
    
  </channel>
</rss>
