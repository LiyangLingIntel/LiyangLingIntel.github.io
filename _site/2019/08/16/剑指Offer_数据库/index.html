<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="孤独是人生的常态吗？">
    <meta name="keywords"  content="leonling, 凌丽阳, LEON's Blog ">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="剑指Offer-数据库&SQL - LEON的博客 | LEON's Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="[TOC]
">
    
    <meta property="article:published_time" content="2019-08-16T00:00:00Z">
    
    
    <meta property="article:author" content="Lyon Ling">
    
    
    <meta property="article:tag" content="JobHunting">
    
    <meta property="article:tag" content="Foundations">
    
    <meta property="article:tag" content="DataBase">
    
    
    <meta property="og:image" content="http://localhost:4000/img/avatar_2.png">
    <meta property="og:url" content="http://localhost:4000/2019/08/16/%E5%89%91%E6%8C%87Offer_%E6%95%B0%E6%8D%AE%E5%BA%93/">
    <meta property="og:site_name" content="LEON的博客 | LEON's Blog">
    
    <title>剑指Offer-数据库&SQL - LEON的博客 | LEON's Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2019/08/16/%E5%89%91%E6%8C%87Offer_%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">Leon Ling's Blog</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>
    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script>

<script src="/js/simple-jekyll-search.min.js"></script>

    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-kkt.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-kkt.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=JobHunting" title="JobHunting">JobHunting</a>
                        
                        <a class="tag" href="/archive/?tag=Foundations" title="Foundations">Foundations</a>
                        
                        <a class="tag" href="/archive/?tag=DataBase" title="DataBase">DataBase</a>
                        
                    </div>
                    <h1>剑指Offer-数据库&SQL</h1>
                    
                    <h2 class="subheading">数据库基础知识总结</h2>
                    <span class="meta">Posted by Lyon Ling on August 16, 2019</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

                <p>[TOC]</p>

<h2 id="数据库基础"><strong>数据库基础</strong></h2>

<h3 id="1-事务">1. 事务</h3>

<p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f74144be-857a-40cd-8ec7-87626ef4e20b.png" width="400" /></p>

<h4 id="11-acid">1.1 ACID</h4>

<ol>
  <li>
    <p>原子性（Atomicity）</p>

    <p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>

    <p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
  </li>
  <li>
    <p>一致性（Consistency）</p>

    <p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
  </li>
  <li>
    <p>隔离性（Isolation）</p>

    <p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
  </li>
  <li>
    <p>持久性（Durability）</p>

    <p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>

    <p>使用重做日志来保证持久性。</p>
  </li>
</ol>

<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>

<ul>
  <li>只有满足一致性，事务的执行结果才是正确的。</li>
  <li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
  <li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
  <li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/417bc315-4409-48c6-83e0-59e8d405429e.jpg" width="600" /></p>

<h4 id="12-autocommit">1.2 AUTOCOMMIT</h4>

<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code class="highlighter-rouge">START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>

<h3 id="2-并发一致性问题">2. 并发一致性问题</h3>

<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>

<h4 id="21-丢失修改">2.1 丢失修改</h4>

<p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/75184b58-c627-4edc-8dcf-605762ebb733.png" width="400" /></p>

<h4 id="22-读脏数据">2.2 读脏数据</h4>

<p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af0e94d9-502d-4531-938f-d46dd29de52d.png" width="500" /></p>

<h4 id="23-不可重复读">2.3 不可重复读</h4>

<p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66ae164c-ad47-4905-895e-51fe38ce797a.png" width="500" /></p>

<h4 id="24-幻影读">2.4 幻影读</h4>

<p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8fdc577d-552d-4b43-b5e4-a8f98bc2cb51.png" width="400" /></p>

<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>

<h3 id="3-封锁---通过锁保证事务隔离性">3. 封锁 - 通过锁保证事务隔离性</h3>

<h4 id="31-封锁粒度">3.1 封锁粒度</h4>

<p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p>

<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的<u>并发程度</u>就越高。</p>

<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>

<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>

<h4 id="32-封锁类型">3.2 封锁类型</h4>

<h5 id="1-读写锁">1. 读写锁</h5>

<ul>
  <li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
  <li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>

<p>有以下两个规定：</p>

<ul>
  <li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
  <li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>

<p>锁的兼容关系如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">X</th>
      <th style="text-align: center">S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>X</strong></td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">×</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">√</td>
    </tr>
  </tbody>
</table>

<h5 id="2-意向锁">2. 意向锁</h5>

<p>使用<strong>意向锁</strong>（Intention Locks）可以更容易地支持多粒度封锁。</p>

<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>

<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>

<ul>
  <li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
  <li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>

<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>

<p>各种锁的兼容关系如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">X</th>
      <th style="text-align: center">IX</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">IS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>X</strong></td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">×</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>IX</strong></td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">√</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>IS</strong></td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
    </tr>
  </tbody>
</table>

<p>解释如下：</p>

<ul>
  <li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
  <li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>

<h4 id="33-封锁协议">3.3 封锁协议</h4>

<h5 id="1-三级锁协议">1. 三级锁协议</h5>

<ol>
  <li>
    <p><strong>一级封锁协议</strong></p>

    <p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>

    <p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
  </li>
</ol>

<table>
  <thead>
    <tr>
      <th>T1</th>
      <th>T2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lock-x(A)</td>
      <td> </td>
    </tr>
    <tr>
      <td>read A=20</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>lock-x(A)</td>
    </tr>
    <tr>
      <td> </td>
      <td>wait</td>
    </tr>
    <tr>
      <td>write A=19</td>
      <td>.</td>
    </tr>
    <tr>
      <td>commit</td>
      <td>.</td>
    </tr>
    <tr>
      <td>unlock-x(A)</td>
      <td>.</td>
    </tr>
    <tr>
      <td> </td>
      <td>obtain</td>
    </tr>
    <tr>
      <td> </td>
      <td>read A=19</td>
    </tr>
    <tr>
      <td> </td>
      <td>write A=21</td>
    </tr>
    <tr>
      <td> </td>
      <td>commit</td>
    </tr>
    <tr>
      <td> </td>
      <td>unlock-x(A2)</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p><strong>二级封锁协议</strong></p>

    <p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>

    <p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
  </li>
</ol>

<table>
  <thead>
    <tr>
      <th>T1</th>
      <th>T2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lock-x(A)</td>
      <td> </td>
    </tr>
    <tr>
      <td>read A=20</td>
      <td> </td>
    </tr>
    <tr>
      <td>write A=19</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>lock-s(A)</td>
    </tr>
    <tr>
      <td> </td>
      <td>wait</td>
    </tr>
    <tr>
      <td>rollback</td>
      <td>.</td>
    </tr>
    <tr>
      <td>A=20</td>
      <td>.</td>
    </tr>
    <tr>
      <td>unlock-x(A)</td>
      <td>.</td>
    </tr>
    <tr>
      <td> </td>
      <td>obtain</td>
    </tr>
    <tr>
      <td> </td>
      <td>read A=20</td>
    </tr>
    <tr>
      <td> </td>
      <td>unlock-s(A)</td>
    </tr>
    <tr>
      <td> </td>
      <td>commit</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p><strong>三级封锁协议</strong></p>

    <p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>

    <p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
  </li>
</ol>

<table>
  <thead>
    <tr>
      <th>T1</th>
      <th>T2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lock-s(A)</td>
      <td> </td>
    </tr>
    <tr>
      <td>read A=20</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>lock-x(A)</td>
    </tr>
    <tr>
      <td> </td>
      <td>wait</td>
    </tr>
    <tr>
      <td>read A=20</td>
      <td>.</td>
    </tr>
    <tr>
      <td>commit</td>
      <td>.</td>
    </tr>
    <tr>
      <td>unlock-s(A)</td>
      <td>.</td>
    </tr>
    <tr>
      <td> </td>
      <td>obtain</td>
    </tr>
    <tr>
      <td> </td>
      <td>read A=20</td>
    </tr>
    <tr>
      <td> </td>
      <td>write A=19</td>
    </tr>
    <tr>
      <td> </td>
      <td>commit</td>
    </tr>
    <tr>
      <td> </td>
      <td>unlock-X(A)</td>
    </tr>
  </tbody>
</table>

<h5 id="2-两段锁协议">2. 两段锁协议</h5>

<p>加锁和解锁分为两个阶段进行。</p>

<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>

<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="34-mysql-隐式与显示锁定">3.4 MySQL 隐式与显示锁定</h4>

<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>

<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">LOCK</span> <span class="k">In</span> <span class="k">SHARE</span> <span class="k">MODE</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="4-隔离级别">4. 隔离级别</h3>

<h4 id="41-未提交读read-uncommitted">4.1 未提交读（READ UNCOMMITTED）</h4>

<p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>

<h4 id="42-提交读read-committed">4.2 提交读（READ COMMITTED）</h4>

<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>

<h4 id="43-可重复读repeatable-read">4.3 可重复读（REPEATABLE READ）</h4>

<p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>

<h4 id="44-可串行化serializable">4.4 可串行化（SERIALIZABLE）</h4>

<p>强制事务串行执行。</p>

<p>需要加锁实现，而其它隔离级别通常不需要。</p>

<table>
  <thead>
    <tr>
      <th>隔离级别</th>
      <th>脏读</th>
      <th>不可重复读</th>
      <th>幻影读</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>未提交读</td>
      <td>√</td>
      <td>√</td>
      <td>√</td>
    </tr>
    <tr>
      <td>提交读</td>
      <td>×</td>
      <td>√</td>
      <td>√</td>
    </tr>
    <tr>
      <td>可重复读</td>
      <td>×</td>
      <td>×</td>
      <td>√</td>
    </tr>
    <tr>
      <td>可串行化</td>
      <td>×</td>
      <td>×</td>
      <td>×</td>
    </tr>
  </tbody>
</table>

<h3 id="5多版本并发控制mvcc">5.多版本并发控制(MVCC)</h3>

<p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>

<h4 id="51-版本号">5.1 版本号</h4>

<ul>
  <li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
  <li>事务版本号：事务开始时的系统版本号。</li>
</ul>

<h4 id="52-隐藏的列">5.2 隐藏的列</h4>

<p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>

<ul>
  <li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
  <li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>

<h4 id="53-undo-日志">5.3 Undo 日志</h4>

<p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" alt="img" /></p>

<h4 id="54-实现过程">5,4 实现过程</h4>

<p>以下实现过程针对可重复读隔离级别。</p>

<p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p>

<ul>
  <li>
    <p>SELECT</p>

    <p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>

    <p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
  </li>
  <li>
    <p>INSERT</p>

    <p>将当前系统版本号作为数据行快照的创建版本号。</p>
  </li>
  <li>
    <p>DELETE</p>

    <p>将当前系统版本号作为数据行快照的删除版本号。</p>
  </li>
  <li>
    <p>UPDATE</p>

    <p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
  </li>
</ul>

<h4 id="55-快照读与当前读">5.5 快照读与当前读</h4>

<ol>
  <li>
    <p>快照读</p>

    <p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
  </li>
</ol>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table</span> <span class="p">...;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>
    <p>当前读</p>

    <p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
  </li>
</ol>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table</span> <span class="k">where</span> <span class="o">?</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table</span> <span class="k">where</span> <span class="o">?</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="k">insert</span><span class="p">;</span>
<span class="k">update</span><span class="p">;</span>
<span class="k">delete</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="6-next-key-locks">6. Next-Key Locks</h3>

<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>

<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>

<h4 id="61-record-locks">6.1 Record Locks</h4>

<p>锁定一个记录上的索引，而不是记录本身。</p>

<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>

<h4 id="62-gap-locks">6.2 Gap Locks</h4>

<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="k">c</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="k">c</span> <span class="k">BETWEEN</span> <span class="mi">10</span> <span class="k">and</span> <span class="mi">20</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="63-next-key-locks">6.3 Next-Key Locks</h4>

<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="p">(</span><span class="o">-</span><span class="err">∞</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
<span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="o">+</span><span class="err">∞</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="7-关系数据库设计理论">7. 关系数据库设计理论</h3>

<h4 id="71-函数依赖">7.1 函数依赖</h4>

<p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>

<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>

<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>

<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>

<h3 id="72-异常">7.2 异常</h3>

<p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>

<table>
  <thead>
    <tr>
      <th>Sno</th>
      <th>Sname</th>
      <th>Sdept</th>
      <th>Mname</th>
      <th>Cname</th>
      <th>Grade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>学生-1</td>
      <td>学院-1</td>
      <td>院长-1</td>
      <td>课程-1</td>
      <td>90</td>
    </tr>
    <tr>
      <td>2</td>
      <td>学生-2</td>
      <td>学院-2</td>
      <td>院长-2</td>
      <td>课程-2</td>
      <td>80</td>
    </tr>
    <tr>
      <td>2</td>
      <td>学生-2</td>
      <td>学院-2</td>
      <td>院长-2</td>
      <td>课程-1</td>
      <td>100</td>
    </tr>
    <tr>
      <td>3</td>
      <td>学生-3</td>
      <td>学院-2</td>
      <td>院长-2</td>
      <td>课程-2</td>
      <td>95</td>
    </tr>
  </tbody>
</table>

<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>

<ul>
  <li>冗余数据：例如 <code class="highlighter-rouge">学生-2</code> 出现了两次。</li>
  <li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
  <li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code class="highlighter-rouge">课程-1</code> 需要删除第一行和第三行，那么 <code class="highlighter-rouge">学生-1</code> 的信息就会丢失。</li>
  <li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>

<h3 id="73-范式">7.3 范式</h3>

<p>范式理论是为了解决以上提到四种异常。</p>

<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>

<h5 id="1-第一范式-1nf">1. 第一范式 (1NF)]</h5>

<p>属性不可分。</p>

<h5 id="2-第二范式-2nf">2. 第二范式 (2NF)</h5>

<p>每个非主属性完全函数依赖于键码。</p>

<p>可以通过分解来满足。</p>

<p><strong>分解前</strong></p>

<table>
  <thead>
    <tr>
      <th>Sno</th>
      <th>Sname</th>
      <th>Sdept</th>
      <th>Mname</th>
      <th>Cname</th>
      <th>Grade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>学生-1</td>
      <td>学院-1</td>
      <td>院长-1</td>
      <td>课程-1</td>
      <td>90</td>
    </tr>
    <tr>
      <td>2</td>
      <td>学生-2</td>
      <td>学院-2</td>
      <td>院长-2</td>
      <td>课程-2</td>
      <td>80</td>
    </tr>
    <tr>
      <td>2</td>
      <td>学生-2</td>
      <td>学院-2</td>
      <td>院长-2</td>
      <td>课程-1</td>
      <td>100</td>
    </tr>
    <tr>
      <td>3</td>
      <td>学生-3</td>
      <td>学院-2</td>
      <td>院长-2</td>
      <td>课程-2</td>
      <td>95</td>
    </tr>
  </tbody>
</table>

<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>

<ul>
  <li>Sno -&gt; Sname, Sdept</li>
  <li>Sdept -&gt; Mname</li>
  <li>Sno, Cname-&gt; Grade</li>
</ul>

<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>

<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>

<p><strong>分解后</strong></p>

<p>关系-1</p>

<table>
  <thead>
    <tr>
      <th>Sno</th>
      <th>Sname</th>
      <th>Sdept</th>
      <th>Mname</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>学生-1</td>
      <td>学院-1</td>
      <td>院长-1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>学生-2</td>
      <td>学院-2</td>
      <td>院长-2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>学生-3</td>
      <td>学院-2</td>
      <td>院长-2</td>
    </tr>
  </tbody>
</table>

<p>有以下函数依赖：</p>

<ul>
  <li>Sno -&gt; Sname, Sdept</li>
  <li>Sdept -&gt; Mname</li>
</ul>

<p>关系-2</p>

<table>
  <thead>
    <tr>
      <th>Sno</th>
      <th>Cname</th>
      <th>Grade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>课程-1</td>
      <td>90</td>
    </tr>
    <tr>
      <td>2</td>
      <td>课程-2</td>
      <td>80</td>
    </tr>
    <tr>
      <td>2</td>
      <td>课程-1</td>
      <td>100</td>
    </tr>
    <tr>
      <td>3</td>
      <td>课程-2</td>
      <td>95</td>
    </tr>
  </tbody>
</table>

<p>有以下函数依赖：</p>

<ul>
  <li>Sno, Cname -&gt; Grade</li>
</ul>

<h5 id="3-第三范式-3nf">3. 第三范式 (3NF)</h5>

<p>非主属性不传递函数依赖于键码。</p>

<p>上面的 关系-1 中存在以下传递函数依赖：</p>

<ul>
  <li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>

<p>可以进行以下分解：</p>

<p>关系-11</p>

<table>
  <thead>
    <tr>
      <th>Sno</th>
      <th>Sname</th>
      <th>Sdept</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>学生-1</td>
      <td>学院-1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>学生-2</td>
      <td>学院-2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>学生-3</td>
      <td>学院-2</td>
    </tr>
  </tbody>
</table>

<p>关系-12</p>

<table>
  <thead>
    <tr>
      <th>Sdept</th>
      <th>Mname</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>学院-1</td>
      <td>院长-1</td>
    </tr>
    <tr>
      <td>学院-2</td>
      <td>院长-2</td>
    </tr>
  </tbody>
</table>

<h3 id="8-er-图">8. ER 图</h3>

<p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>

<p>用来进行关系型数据库系统的概念设计。</p>

<h4 id="81-实体的三种联系">8.1 实体的三种联系</h4>

<p>包含一对一，一对多，多对多三种。</p>

<ul>
  <li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
  <li>如果是一对一，画两个带箭头的线段；</li>
  <li>如果是多对多，画两个不带箭头的线段。</li>
</ul>

<p>下图的 Course 和 Student 是一对多的关系。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt="img" /></p>

<h4 id="82-表示出现多次的关系">8.2 表示出现多次的关系</h4>

<p>一个实体在联系出现几次，就要用几条线连接。</p>

<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt="img" /></p>

<h4 id="83-联系的多向性">8.3 联系的多向性</h4>

<p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt="img" /></p>

<h4 id="84-表示子类">8.4 表示子类</h4>

<p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt="img" /></p>

<h2 id="mysql">MySQL</h2>

<h3 id="1-索引">1. 索引</h3>

<h4 id="11--b-tree-原理">1.1  B+ Tree 原理</h4>

<h5 id="111-数据结构">1.1.1 数据结构</h5>

<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>

<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>

<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img" /></p>

<h5 id="112-操作">1.1.2 操作</h5>

<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>

<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>

<h5 id="113-与红黑树的比较">1.1.3 与红黑树的比较</h5>

<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>

<ol>
  <li>
    <p>更少的查找次数</p>

    <p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p>

    <p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
  </li>
  <li>
    <p>利用磁盘预读特性</p>

    <p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>

    <p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
  </li>
</ol>

<h4 id="12-mysql-索引">1.2 MySQL 索引</h4>

<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>

<h5 id="121-btree-索引">1.2.1 B+Tree 索引</h5>

<p>是大多数 MySQL 存储引擎的默认索引类型。</p>

<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>

<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>

<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>

<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>

<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img" /></p>

<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png" alt="img" /></p>

<h5 id="122-哈希索引">1.2.2 哈希索引</h5>

<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>

<ul>
  <li>无法用于排序与分组；</li>
  <li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>

<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>

<h5 id="123-全文索引">1.2.3 全文索引</h5>

<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>

<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>

<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>

<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>

<h5 id="124-空间数据索引">1.2.4. 空间数据索引</h5>

<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>

<p>必须使用 GIS 相关的函数来维护数据。</p>

<h4 id="13-索引优化">1.3 索引优化</h4>

<h5 id="131-独立的列">1.3.1 独立的列</h5>

<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>

<p>例如下面的查询不能使用 actor_id 列的索引：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="n">actor_id</span> <span class="k">FROM</span> <span class="n">sakila</span><span class="p">.</span><span class="n">actor</span> <span class="k">WHERE</span> <span class="n">actor_id</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="132-多列索引">1.3.2 多列索引</h5>

<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="n">film_id</span><span class="p">,</span> <span class="n">actor_</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">sakila</span><span class="p">.</span><span class="n">film_actor</span>
<span class="k">WHERE</span> <span class="n">actor_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">film_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="133-索引列的顺序">1.3.3 索引列的顺序</h5>

<p>让选择性最强的索引列放在前面。</p>

<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>

<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">staff_id</span><span class="p">)</span><span class="o">/</span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">staff_id_selectivity</span><span class="p">,</span>
<span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">customer_id</span><span class="p">)</span><span class="o">/</span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">customer_id_selectivity</span><span class="p">,</span>
<span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">payment</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<pre><code class="language-pseudocode">   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049

</code></pre>

<h5 id="134-前缀索引">1.3.4 前缀索引</h5>

<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>

<p>前缀长度的选取需要根据索引选择性来确定。</p>

<h5 id="135-覆盖索引">1.3.5 覆盖索引</h5>

<p>索引包含所有需要查询的字段的值。</p>

<p>具有以下优点：</p>

<ul>
  <li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
  <li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
  <li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>

<h4 id="14-索引的优点">1.4 索引的优点</h4>

<ul>
  <li>大大减少了服务器需要扫描的数据行数。</li>
  <li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
  <li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>

<h4 id="15-索引的使用条件">1.5 索引的使用条件</h4>

<ul>
  <li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
  <li>对于中到大型的表，索引就非常有效；</li>
  <li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>

<h3 id="2-查询性能优化">2. 查询性能优化</h3>

<h4 id="21-使用-explain-进行分析">2.1 使用 Explain 进行分析</h4>

<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>

<p>比较重要的字段有：</p>

<ul>
  <li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
  <li>key : 使用的索引</li>
  <li>rows : 扫描的行数</li>
</ul>

<h4 id="22-优化数据访问">2.2 优化数据访问</h4>

<h5 id="221-减少请求的数据量">2.2.1 减少请求的数据量</h5>

<ul>
  <li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
  <li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
  <li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>

<h5 id="222-减少服务器端扫描的行数">2.2.2 减少服务器端扫描的行数</h5>

<p>最有效的方式是使用索引来覆盖查询。</p>

<h4 id="23-重构查询方式">2.3 重构查询方式</h4>

<h5 id="231-切分大查询">2.3.1 切分大查询</h5>

<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">messages</span> <span class="k">WHERE</span> <span class="k">create</span> <span class="o">&lt;</span> <span class="n">DATE_SUB</span><span class="p">(</span><span class="n">NOW</span><span class="p">(),</span> <span class="n">INTERVAL</span> <span class="mi">3</span> <span class="k">MONTH</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<pre><code class="language-pseudocode">rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected &gt; 0
</code></pre>

<h5 id="232-分解大连接查询">2.3.2 分解大连接查询</h5>

<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>

<ul>
  <li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
  <li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
  <li>减少锁竞争；</li>
  <li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
  <li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tab</span>
<span class="k">JOIN</span> <span class="n">tag_post</span> <span class="k">ON</span> <span class="n">tag_post</span><span class="p">.</span><span class="n">tag_id</span><span class="o">=</span><span class="n">tag</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span> <span class="n">post</span> <span class="k">ON</span> <span class="n">tag_post</span><span class="p">.</span><span class="n">post_id</span><span class="o">=</span><span class="n">post</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">tag</span><span class="p">.</span><span class="n">tag</span><span class="o">=</span><span class="s1">'mysql'</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tag</span> <span class="k">WHERE</span> <span class="n">tag</span><span class="o">=</span><span class="s1">'mysql'</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tag_post</span> <span class="k">WHERE</span> <span class="n">tag_id</span><span class="o">=</span><span class="mi">1234</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">post</span> <span class="k">WHERE</span> <span class="n">post</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">123</span><span class="p">,</span><span class="mi">456</span><span class="p">,</span><span class="mi">567</span><span class="p">,</span><span class="mi">9098</span><span class="p">,</span><span class="mi">8904</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="3-存储引擎">3. 存储引擎</h3>

<h4 id="31-innodb">3.1 InnoDB</h4>

<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>

<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>

<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>

<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>

<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>

<h4 id="32-myisam">3.2 MyISAM</h4>

<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>

<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>

<p>不支持事务。</p>

<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>

<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>

<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>

<h4 id="33-比较">3.3 比较</h4>

<ul>
  <li>
    <p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p>
  </li>
  <li>
    <p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p>
  </li>
  <li>
    <p>外键：InnoDB 支持外键。</p>
  </li>
  <li>
    <p>备份：InnoDB 支持在线热备份。</p>
  </li>
  <li>
    <p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p>
  </li>
  <li>
    <p>其它特性：MyISAM 支持压缩表和空间数据索引。</p>
  </li>
</ul>

<h4 id="sql中where和having的区别">sql中where和having的区别</h4>

<ul>
  <li>“Where” 是一个约束声明，使用Where来约束来自数据库的数据，Where是在结果返回之前起作用的，且<strong>Where中不能使用聚合函数</strong>。</li>
  <li>“Having”是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，<strong>在Having中可以使用聚合函数</strong>。</li>
</ul>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2019/08/15/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9Pyspark-DataFrame%E7%9A%84%E5%88%97%E5%90%8D/"
                            data-toggle="tooltip" data-placement="top" title="如何修改 PySpark Dataframe 的列名">
                            Previous<br>
                            <span>如何修改 PySpark Dataframe 的列名</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/08/23/Spark%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" data-toggle="tooltip"
                            data-placement="top" title="Spark编程优化经验">
                            Next<br>
                            <span>Spark编程优化经验</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>

            <!-- Side Catalog Container -->
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        </a>
        
        
                <a data-sort="0043" 
                    href="/archive/?tag=Tricks"
                    title="Tricks"
                    rel="8">Tricks</a>
        
                <a data-sort="0040" 
                    href="/archive/?tag=JobHunting"
                    title="JobHunting"
                    rel="11">JobHunting</a>
        
                <a data-sort="0042" 
                    href="/archive/?tag=%E8%BD%AC%E8%BD%BD"
                    title="转载"
                    rel="9">转载</a>
        
                <a data-sort="0042" 
                    href="/archive/?tag=Foundations"
                    title="Foundations"
                    rel="9">Foundations</a>
        
                <a data-sort="0044" 
                    href="/archive/?tag=Notes"
                    title="Notes"
                    rel="7">Notes</a>
        
                <a data-sort="0044" 
                    href="/archive/?tag=Programing"
                    title="Programing"
                    rel="7">Programing</a>
        
                <a data-sort="0044" 
                    href="/archive/?tag=Python"
                    title="Python"
                    rel="7">Python</a>
        
                <a data-sort="0045" 
                    href="/archive/?tag=DataScience"
                    title="DataScience"
                    rel="6">DataScience</a>
        
                <a data-sort="0045" 
                    href="/archive/?tag=MachineLearning"
                    title="MachineLearning"
                    rel="6">MachineLearning</a>
        
                <a data-sort="0046" 
                    href="/archive/?tag=BigData"
                    title="BigData"
                    rel="5">BigData</a>
        
                <a data-sort="0046" 
                    href="/archive/?tag=Spark"
                    title="Spark"
                    rel="5">Spark
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="https://cherishher.github.io/">Max Qi</a></li>
  <br>
  
  <li><a href="https://www.guchenghao.com/">Gu Chenghao</a></li>
  <br>
  
  <li><a href="https://syenpark.github.io/">Syen Park</a></li>
  <br>
  
  <li><a href="https://dojozheng.com/">DOJO Zheng</a></li>
  <br>
  
</ul>

            </div>
        </div>
    </div>

</article>

<!-- add support for mathjax by voleking-->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    SVG: {
      scale: 90
    },
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true,
    }
  });
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG">
</script>

<script>
  window.Lazyload.js('https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js', function () {
    mermaid.initialize({
      startOnLoad: true
    });
    mermaid.init(undefined, '.language-mermaid');
  });
</script>

<script>
  window.Lazyload.js(['https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js', 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js'], function () {
    var $canvas = null,
      $this = null,
      _ctx = null,
      _text = '';
    $('.language-chart').each(function () {
      $this = $(this);
      $canvas = $('<canvas></canvas>');
      _text = $this.text();
      $this.text('').append($canvas);
      _ctx = $canvas.get(0).getContext('2d');
      (_ctx && _text) && (new Chart(_ctx, JSON.parse(_text)) && $this.attr('data-processed', true));
    });
  });
</script>




<!--Gitalk评论start  -->

<!-- Gitalk end -->


<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "leon_disqus";
    var disqus_identifier = "/2019/08/16/剑指Offer_数据库";
    var disqus_url = "http://localhost:4000/2019/08/16/%E5%89%91%E6%8C%87Offer_%E6%95%B0%E6%8D%AE%E5%BA%93/";

    (function () {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async (u, c) {
        var d = document,
            t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) {
            o.addEventListener('load', function (e) {
                c(null, e);
            }, false);
        }
        s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async ("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js", function () {
        anchors.options = {
            visible: 'hover',
            placement: 'right',
            // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link {
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top: -0.1em;
        }
    }
</style>


<!-- Go to www.addthis.com/dashboard to customize your tools -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5ddc8a0647bb126e"></script>

    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  <li>
    <a target="_blank" href="https://www.zhihu.com/people/lyonling">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa  fa-stack-1x fa-inverse">知</i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="http://weibo.com/5395966937">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/lyonling">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="https://www.linkedin.com/in/liyang-ling-678220117">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; Leon Ling's Blog 2018-2019
                    <br>
                    Powered by <a href="https://jekyllrb.com/">Jekyll</a> Theme <a href="https://github.com/Huxpro/huxpro.github.io">HuxPro</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-131740306-1';
    var _gaDomain = 'auto';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
