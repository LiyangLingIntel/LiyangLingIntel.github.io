---
layout:     post
title:      "浅谈C++内存分配的方法"
subtitle:   malloc vs calloc vs realloc
date:       2019-03-19
author:     Lyon Ling
header-img: img/post-bg-memoryallocate.png
catalog: true
tags:
    - C++
    - Programming
    - Foundations
---

> 因为并行程序设计课程需要用C/C++进行编程，所以现在需要捡起积灰已久的C++，回头看看，很惭愧很多语法和内部编译细节都忘的差不多了，这里一边重新学习一边积累，希望未来的某天会有所帮助吧。

### C++内存分配的方式

* **从静态存储区域分配**
  内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量、静态变量。
* **在栈上创建**
  在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
* **从堆上分配，亦称动态内存分配**
  程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由用户决定。

### `malloc()` vs `calloc()` vs  `realloc()`

首先看下函数声明：

```cpp
void* malloc(unsigned size);
// 在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的
// 首地址.

void* calloc(size_t numElements, size_t sizeOfElement); 
// 与malloc相似，参数sizeOfElement为申请地址的单位元素长度，numElements为元素个数，即在内存中申请
// numElements*sizeOfElement字节大小的连续地址空间.

void* realloc(void* ptr, unsigned newsize);  
// 给一个已经分配了地址的指针重新分配空间，参数ptr为原有的空间地址，newsize是重新申请的地址长度，返回
// 新的内存指针.
```

**区别：**

* `malloc()`不能初始化所分配的内存空间， 而`calloc()`能. 

  如果由`malloc()`函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0; 反之， 如果这部分内存曾经被分配过， 则其中可能遗留有各种各样的数据. 也就是说，使用`malloc()`的程序开始时(内存空间还没有被重新分配)能正常进行，但经过一段时间(内存空间还已经被重新分配)可能会出现问题。

* `calloc()`会将所分配的内存空间中的每一位都初始化为**0**。

  如果为**字符类型**或**整数类型**的元素分配内存，那么这些元素将保证会被初始化为**0**；

  如果你是为**指针类型**的元素分配内存，那么这些元素通常会被初始化为**空指针**；

  如果为**实型**数据分配内存，则这些元素会被初始化为**浮点型的零**。

* `malloc()`向系统申请分配指定size个字节的内存空间，返回类型是` void*`类型。

  `void*`表示未确定类型的指针. C/C++规定，`void*` 类型可以强制转换为任何其它类型的指针。

* `realloc()`可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变。当然，对于缩小，则被缩小的那一部分的内容会丢失。

  `realloc()`并不保证调整后的内存空间和原来的内存空间保持同一内存地址。相反，`realloc()`返回的指针很可能指向一个新的地址。

* `realloc()`是从堆上分配内存的。当扩大一块内存空间时，`realloc()`试图直接从堆上现存的数据后面的那些字节中获得附加的字节；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上。这句话传递的一个重要的信息就是数据可能被移动。

无论是上述哪一种方法申请的内存最后都需要使用`free` 或者 `delete`释放，否则就非常容易造成内存泄漏。