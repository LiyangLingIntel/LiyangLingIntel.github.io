I"N;<p>[TOC]</p>

<h2 id="1-计算机网络体系结构">1. 计算机网络体系结构</h2>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="500" /></p>

<h3 id="11-五层协议">1.1 五层协议</h3>

<ul>
  <li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
  <li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<strong>传输控制协议 TCP</strong>，提供面向连接、可靠的数据传输服务，数据单位为报文段；<strong>用户数据报协议 UDP</strong>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
  <li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
  <li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
  <li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>

<h3 id="12-osi">1.2. OSI</h3>

<p>其中表示层和会话层用途如下：</p>

<ul>
  <li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
  <li><strong>会话层</strong> ：建立及管理会话。</li>
</ul>

<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>

<h3 id="13-tcpip">1.3. TCP/IP</h3>

<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>

<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" width="300" /></p>

<h3 id="14-数据在各层之间的传递过程">1.4 数据在各层之间的传递过程</h3>

<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>

<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>

<h2 id="2-http">2. HTTP</h2>

<h3 id="21-基础概念">2.1 基础概念</h3>

<h4 id="211-uri">2.1.1 URI</h4>

<p>URI 包含 URL 和 URN。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" width="550" /></p>

<h4 id="212-请求和响应报文">2.1.2 请求和响应报文</h4>

<h5 id="2121-请求报文">2.1.2.1 请求报文</h5>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_RequestMessageExample.png" alt="img" /></p>

<h5 id="2122-响应报文">2.1.2.2 响应报文</h5>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_ResponseMessageExample.png" alt="img" /></p>

<h3 id="22-http-方法">2.2 HTTP 方法</h3>

<p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>

<h4 id="221-get">2.2.1 GET</h4>

<blockquote>
  <p>获取资源</p>
</blockquote>

<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>

<h4 id="222-head">2.2.2 HEAD</h4>

<blockquote>
  <p>获取报文首部</p>
</blockquote>

<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>

<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>

<h4 id="223-post">2.2.3 POST</h4>

<blockquote>
  <p>传输实体主体</p>
</blockquote>

<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>

<p>更多 POST 与 GET 的比较请见第九章。</p>

<h4 id="223-put">2.2.3 PUT</h4>

<blockquote>
  <p>上传文件</p>
</blockquote>

<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

<span class="nt">&lt;p&gt;</span>New File<span class="nt">&lt;/p&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="224-patch">2.2.4 PATCH</h4>

<blockquote>
  <p>对资源进行部分修改</p>
</blockquote>

<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="225-delete">2.2.5 DELETE</h4>

<blockquote>
  <p>删除文件</p>
</blockquote>

<p>与 PUT 功能相反，并且同样不带验证机制。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>DELETE /file.html HTTP/1.1
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="226-options">2.2.6 OPTIONS</h4>

<blockquote>
  <p>查询支持的方法</p>
</blockquote>

<p>查询指定的 URL 能够支持的方法。</p>

<p>会返回 <code class="highlighter-rouge">Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>

<h4 id="227-connect">2.2.7 CONNECT</h4>

<blockquote>
  <p>要求在与代理服务器通信时建立隧道</p>
</blockquote>

<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>CONNECT www.example.com:443 HTTP/1.1Copy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg" alt="img" /></p>

<h4 id="229-trace">2.2.9 TRACE</h4>

<blockquote>
  <p>追踪路径</p>
</blockquote>

<p>服务器会将通信路径返回给客户端。</p>

<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>

<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>

<h3 id="23-http-状态码">2.3 HTTP 状态码</h3>

<p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>

<table>
  <thead>
    <tr>
      <th>状态码</th>
      <th>类别</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1XX</td>
      <td>Informational（信息性状态码）</td>
      <td>接收的请求正在处理</td>
    </tr>
    <tr>
      <td>2XX</td>
      <td>Success（成功状态码）</td>
      <td>请求正常处理完毕</td>
    </tr>
    <tr>
      <td>3XX</td>
      <td>Redirection（重定向状态码）</td>
      <td>需要进行附加操作以完成请求</td>
    </tr>
    <tr>
      <td>4XX</td>
      <td>Client Error（客户端错误状态码）</td>
      <td>服务器无法处理请求</td>
    </tr>
    <tr>
      <td>5XX</td>
      <td>Server Error（服务器错误状态码）</td>
      <td>服务器处理请求出错</td>
    </tr>
  </tbody>
</table>

<h4 id="231-1xx-信息">2.3.1 1XX 信息</h4>

<ul>
  <li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>

<h4 id="232-2xx-成功">2.3.2 2XX 成功</h4>

<ul>
  <li><strong>200 OK</strong></li>
  <li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
  <li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>

<h4 id="233-3xx-重定向">2.3.3 3XX 重定向</h4>

<ul>
  <li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
  <li><strong>302 Found</strong> ：临时性重定向</li>
  <li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
  <li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
  <li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
  <li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>

<h4 id="234-4xx-客户端错误">2.3.4 4XX 客户端错误</h4>

<ul>
  <li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
  <li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
  <li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
  <li><strong>404 Not Found</strong></li>
</ul>

<h4 id="235-5xx-服务器错误">2.3.5 5XX 服务器错误</h4>

<ul>
  <li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
  <li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>

<h3 id="24-http-首部">2.4 HTTP 首部</h3>

<p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>

<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>

<h4 id="241-通用首部字段">2.4.1 通用首部字段</h4>

<table>
  <thead>
    <tr>
      <th>首部字段名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Cache-Control</td>
      <td>控制缓存的行为</td>
    </tr>
    <tr>
      <td>Connection</td>
      <td>控制不再转发给代理的首部字段、管理持久连接</td>
    </tr>
    <tr>
      <td>Date</td>
      <td>创建报文的日期时间</td>
    </tr>
    <tr>
      <td>Pragma</td>
      <td>报文指令</td>
    </tr>
    <tr>
      <td>Trailer</td>
      <td>报文末端的首部一览</td>
    </tr>
    <tr>
      <td>Transfer-Encoding</td>
      <td>指定报文主体的传输编码方式</td>
    </tr>
    <tr>
      <td>Upgrade</td>
      <td>升级为其他协议</td>
    </tr>
    <tr>
      <td>Via</td>
      <td>代理服务器的相关信息</td>
    </tr>
    <tr>
      <td>Warning</td>
      <td>错误通知</td>
    </tr>
  </tbody>
</table>

<h4 id="242-请求首部字段">2.4.2 请求首部字段</h4>

<table>
  <thead>
    <tr>
      <th>首部字段名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Accept</td>
      <td>用户代理可处理的媒体类型</td>
    </tr>
    <tr>
      <td>Accept-Charset</td>
      <td>优先的字符集</td>
    </tr>
    <tr>
      <td>Accept-Encoding</td>
      <td>优先的内容编码</td>
    </tr>
    <tr>
      <td>Accept-Language</td>
      <td>优先的语言（自然语言）</td>
    </tr>
    <tr>
      <td>Authorization</td>
      <td>Web 认证信息</td>
    </tr>
    <tr>
      <td>Expect</td>
      <td>期待服务器的特定行为</td>
    </tr>
    <tr>
      <td>From</td>
      <td>用户的电子邮箱地址</td>
    </tr>
    <tr>
      <td>Host</td>
      <td>请求资源所在服务器</td>
    </tr>
    <tr>
      <td>If-Match</td>
      <td>比较实体标记（ETag）</td>
    </tr>
    <tr>
      <td>If-Modified-Since</td>
      <td>比较资源的更新时间</td>
    </tr>
    <tr>
      <td>If-None-Match</td>
      <td>比较实体标记（与 If-Match 相反）</td>
    </tr>
    <tr>
      <td>If-Range</td>
      <td>资源未更新时发送实体 Byte 的范围请求</td>
    </tr>
    <tr>
      <td>If-Unmodified-Since</td>
      <td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
    </tr>
    <tr>
      <td>Max-Forwards</td>
      <td>最大传输逐跳数</td>
    </tr>
    <tr>
      <td>Proxy-Authorization</td>
      <td>代理服务器要求客户端的认证信息</td>
    </tr>
    <tr>
      <td>Range</td>
      <td>实体的字节范围请求</td>
    </tr>
    <tr>
      <td>Referer</td>
      <td>对请求中 URI 的原始获取方</td>
    </tr>
    <tr>
      <td>TE</td>
      <td>传输编码的优先级</td>
    </tr>
    <tr>
      <td>User-Agent</td>
      <td>HTTP 客户端程序的信息</td>
    </tr>
  </tbody>
</table>

<h4 id="243-响应首部字段">2.4.3 响应首部字段</h4>

<table>
  <thead>
    <tr>
      <th>首部字段名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Accept-Ranges</td>
      <td>是否接受字节范围请求</td>
    </tr>
    <tr>
      <td>Age</td>
      <td>推算资源创建经过时间</td>
    </tr>
    <tr>
      <td>ETag</td>
      <td>资源的匹配信息</td>
    </tr>
    <tr>
      <td>Location</td>
      <td>令客户端重定向至指定 URI</td>
    </tr>
    <tr>
      <td>Proxy-Authenticate</td>
      <td>代理服务器对客户端的认证信息</td>
    </tr>
    <tr>
      <td>Retry-After</td>
      <td>对再次发起请求的时机要求</td>
    </tr>
    <tr>
      <td>Server</td>
      <td>HTTP 服务器的安装信息</td>
    </tr>
    <tr>
      <td>Vary</td>
      <td>代理服务器缓存的管理信息</td>
    </tr>
    <tr>
      <td>WWW-Authenticate</td>
      <td>服务器对客户端的认证信息</td>
    </tr>
  </tbody>
</table>

<h4 id="244-实体首部字段">2.4.4 实体首部字段</h4>

<table>
  <thead>
    <tr>
      <th>首部字段名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Allow</td>
      <td>资源可支持的 HTTP 方法</td>
    </tr>
    <tr>
      <td>Content-Encoding</td>
      <td>实体主体适用的编码方式</td>
    </tr>
    <tr>
      <td>Content-Language</td>
      <td>实体主体的自然语言</td>
    </tr>
    <tr>
      <td>Content-Length</td>
      <td>实体主体的大小</td>
    </tr>
    <tr>
      <td>Content-Location</td>
      <td>替代对应资源的 URI</td>
    </tr>
    <tr>
      <td>Content-MD5</td>
      <td>实体主体的报文摘要</td>
    </tr>
    <tr>
      <td>Content-Range</td>
      <td>实体主体的位置范围</td>
    </tr>
    <tr>
      <td>Content-Type</td>
      <td>实体主体的媒体类型</td>
    </tr>
    <tr>
      <td>Expires</td>
      <td>实体主体过期的日期时间</td>
    </tr>
    <tr>
      <td>Last-Modified</td>
      <td>资源的最后修改日期时间</td>
    </tr>
  </tbody>
</table>

<h3 id="25-具体应用">2.5 具体应用</h3>

<h4 id="251-连接管理">2.5.1 连接管理</h4>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" alt="img" /></p>

<h5 id="2511-短连接与长连接">2.5.1.1 短连接与长连接</h5>

<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>

<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>

<ul>
  <li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code class="highlighter-rouge">Connection : close</code>；</li>
  <li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code class="highlighter-rouge">Connection : Keep-Alive</code>。</li>
</ul>

<h5 id="2512-流水线">2.5.1.2 流水线</h5>

<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>

<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>

<h4 id="252-cookie">2.5.2 Cookie</h4>

<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>

<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>

<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>

<h4 id="2521-用途">2.5.2.1 用途</h4>

<ul>
  <li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
  <li>个性化设置（如用户自定义设置、主题等）</li>
  <li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>

<h5 id="2522-创建过程">2.5.2.2 创建过程</h5>

<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>

<pre><code class="language-pseudocode">HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
</code></pre>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="2523-分类">2.5.2.3 分类</h5>

<ul>
  <li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
  <li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="2524-作用域">2.5.2.4 作用域</h5>

<p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>

<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/”) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>

<ul>
  <li>/docs</li>
  <li>/docs/Web/</li>
  <li>/docs/Web/HTTP</li>
</ul>

<h5 id="2525--javascript">2.5.2.5  JavaScript</h5>

<p>浏览器通过 <code class="highlighter-rouge">document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">yummy_cookie=choco</span><span class="dl">"</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">tasty_cookie=strawberry</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="2526-httponly">2.5.2.6 HttpOnly</h5>

<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code class="highlighter-rouge">document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="err">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="2527-secure">2.5.2.7 Secure</h5>

<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>

<h5 id="2528-session">2.5.2.8 Session</h5>

<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>

<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>

<p>使用 Session 维护用户登录状态的过程如下：</p>

<ul>
  <li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
  <li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
  <li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
  <li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>

<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>

<h5 id="2529-浏览器禁用-cookie">2.5.2.9 浏览器禁用 Cookie</h5>

<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>

<h5 id="25210-cookie-与-session-选择">2.5.2.10 Cookie 与 Session 选择</h5>

<ul>
  <li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
  <li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
  <li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>

<h4 id="253-缓存">2.5.3 缓存</h4>

<h5 id="2531-优点">2.5.3.1 优点</h5>

<ul>
  <li>缓解服务器压力；</li>
  <li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>

<h5 id="2532-实现方法">2.5.3.2 实现方法</h5>

<ul>
  <li>让代理服务器进行缓存；</li>
  <li>让客户端浏览器进行缓存。</li>
</ul>

<h5 id="2533-cache-control">2.5.3.3 Cache-Control</h5>

<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>

<h6 id="25331-禁止进行缓存">2.5.3.3.1 禁止进行缓存</h6>

<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Cache-Control: no-storeCopy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<h6 id="25332-强制确认缓存">2.5.3.3.2 强制确认缓存</h6>

<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Cache-Control: no-cacheCopy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<h6 id="25333-私有缓存和公共缓存">2.5.3.3.3 私有缓存和公共缓存</h6>

<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Cache-Control: privateCopy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Cache-Control: publicCopy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<h6 id="25334-缓存过期机制">2.5.3.3.4 缓存过期机制</h6>

<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>

<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Cache-Control: max-age=31536000
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Expires: Wed, 04 Jul 2012 08:26:05 GMT
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
  <li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>

<h5 id="2534-缓存验证">2.5.3.4 缓存验证</h5>

<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code class="highlighter-rouge">http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>ETag: "82e22293907ce725faf67773957acd12"
</pre></td></tr></tbody></table></code></pre></div></div>

<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>If-None-Match: "82e22293907ce725faf67773957acd12"
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="254-内容协商">2.5.4 内容协商</h4>

<p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>

<h5 id="2541-类型">2.5.4.1 类型</h5>

<p><strong>2.5.4.1.1 服务端驱动型</strong></p>

<p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p>

<p>它存在以下问题：</p>

<ul>
  <li>服务器很难知道客户端浏览器的全部信息；</li>
  <li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li>
  <li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li>
</ul>

<p><strong>2.5.4.1.2 代理驱动型</strong></p>

<p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p>

<h5 id="2542-vary">2.5.4.2 Vary</h5>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Vary: Accept-Language
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p>

<p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code class="highlighter-rouge">Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p>

<h4 id="255-内容编码">2.5.5 内容编码</h4>

<p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p>

<p>常用的内容编码有：gzip、compress、deflate、identity。</p>

<p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p>

<h4 id="256-范围请求">2.5.6 范围请求</h4>

<p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p>

<h5 id="2561-range">2.5.6.1 Range</h5>

<p>在请求报文中添加 Range 首部字段指定请求的范围。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
</pre></td></tr></tbody></table></code></pre></div></div>

<p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="2562-accept-ranges">2.5.6.2 Accept-Ranges</h5>

<p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Accept-Ranges: bytesCopy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="2563-响应状态码">2.5.6.3 响应状态码</h5>

<ul>
  <li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
  <li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>
  <li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
</ul>

<h4 id="257-分块传输编码">2.5.7 分块传输编码</h4>

<p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p>

<h4 id="258-多部分对象集合">2.5.8 多部分对象集合</h4>

<p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p>

<p>例如，上传多个表单时可以使用如下方式：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="259-虚拟主机">2.5.9 虚拟主机</h4>

<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>

<h4 id="2510-通信数据转发">2.5.10 通信数据转发</h4>

<h5 id="25101-代理">2.5.10.1 代理</h5>

<p>代理服务器接受客户端的请求，并且转发给其它服务器。</p>

<p>使用代理的主要目的是：</p>

<ul>
  <li>缓存</li>
  <li>负载均衡</li>
  <li>网络访问控制</li>
  <li>访问日志记录</li>
</ul>

<p>代理服务器分为正向代理和反向代理两种：</p>

<ul>
  <li>用户察觉得到正向代理的存在。</li>
</ul>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" alt="img" /></p>

<ul>
  <li>而反向代理一般位于内部网络中，用户察觉不到。</li>
</ul>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png" alt="img" /></p>

<h5 id="25102-网关">2.5.10.2 网关</h5>

<p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p>

<h5 id="25103-隧道">2.5.10.3 隧道</h5>

<p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>

<h3 id="26-https">2.6 HTTPS</h3>

<p>HTTP 有以下安全性问题：</p>

<ul>
  <li>使用明文进行通信，内容可能会被窃听；</li>
  <li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
  <li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>

<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>

<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg" width="600" /></p>

<h4 id="261-加密">2.6.1 加密</h4>

<h5 id="2611-对称密钥加密">2.6.1.1 对称密钥加密</h5>

<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>

<ul>
  <li>优点：运算速度快；</li>
  <li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600" /></p>

<h5 id="2612-非对称密钥加密">2.6.1.2 非对称密钥加密</h5>

<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>

<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>

<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>

<ul>
  <li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
  <li>缺点：运算速度慢。</li>
</ul>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600" /></p>

<h5 id="2613-https-采用的加密方式">2.6.1.3 HTTPS 采用的加密方式</h5>

<p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" width="600" /></p>

<h4 id="262-认证">2.6.2 认证</h4>

<p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>

<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>

<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>

<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" alt="img" /></p>

<h4 id="263-完整性保护">2.6.3 完整性保护</h4>

<p>SSL 提供报文摘要功能来进行完整性保护。</p>

<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>

<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>

<h4 id="264-https-的缺点">2.6.4 HTTPS 的缺点</h4>

<ul>
  <li>因为需要进行加密解密等过程，因此速度会更慢；</li>
  <li>需要支付证书授权的高额费用。</li>
</ul>

<h3 id="27-http20">2.7 HTTP/2.0</h3>

<h4 id="271-http1x-缺陷">2.7.1 HTTP/1.x 缺陷</h4>

<p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>

<ul>
  <li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
  <li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
  <li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>

<h4 id="272-二进制分帧层">2.7.2 二进制分帧层</h4>

<p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png" width="500" /></p>

<p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>

<ul>
  <li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li>
  <li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li>
  <li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png" width="650" /></p>

<h4 id="273-服务端推送">2.7.3 服务端推送</h4>

<p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" alt="img" /></p>

<h4 id="274-首部压缩">2.7.4 首部压缩</h4>

<p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>

<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>

<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png" width="650" /></p>

<h3 id="28-http11-新特性">2.8 HTTP/1.1 新特性</h3>

<p>详细内容请见上文</p>

<ul>
  <li>默认是长连接</li>
  <li>支持流水线</li>
  <li>支持同时打开多个 TCP 连接</li>
  <li>支持虚拟主机</li>
  <li>新增状态码 100</li>
  <li>支持分块传输编码</li>
  <li>新增缓存处理指令 max-age</li>
</ul>

<h3 id="29-get-和-post-比较">2.9 GET 和 POST 比较</h3>

<h4 id="291-作用">2.9.1 作用</h4>

<p>GET 用于获取资源，而 POST 用于传输实体主体。</p>

<h4 id="292-参数">2.9.2 参数</h4>

<p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>

<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code class="highlighter-rouge">中文</code> 会转换为 <code class="highlighter-rouge">%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code class="highlighter-rouge">%20</code>。POST 参数支持标准字符集。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1Copy to clipboardErrorCopied
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2Copy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="293-安全">2.9.3 安全</h4>

<p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>

<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>

<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>

<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>

<h4 id="294-幂等性">2.9.4 幂等性</h4>

<p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>

<p>所有的安全方法也都是幂等的。</p>

<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>

<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1Copy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>POST /add_row HTTP/1.1   -&gt; Adds a 1nd row
POST /add_row HTTP/1.1   -&gt; Adds a 2nd row
POST /add_row HTTP/1.1   -&gt; Adds a 3rd rowCopy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404Copy to clipboardErrorCopied
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="295-可缓存">2.9.5 可缓存</h4>

<p>如果要对响应进行缓存，需要满足以下条件：</p>

<ul>
  <li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
  <li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
  <li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>

<h4 id="296-xmlhttprequest">2.9.6 XMLHttpRequest</h4>

<p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>

<blockquote>
  <p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>

<ul>
  <li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
  <li>而 GET 方法 Header 和 Data 会一起发送。</li>
</ul>

<h2 id="3-socket">3. Socket</h2>

<h3 id="31-io-模型">3.1 I/O 模型</h3>

<p>一个输入操作通常包括两个阶段：</p>

<ul>
  <li>等待数据准备好</li>
  <li>从内核向进程复制数据</li>
</ul>

<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>

<p>Unix 有五种 I/O 模型：</p>

<ul>
  <li>阻塞式 I/O</li>
  <li>非阻塞式 I/O</li>
  <li>I/O 复用（select 和 poll）</li>
  <li>信号驱动式 I/O（SIGIO）</li>
  <li>异步 I/O（AIO）</li>
</ul>

<h4 id="311-阻塞式-io">3.1.1 阻塞式 I/O</h4>

<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>

<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>

<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">recvfrom</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">src_addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span><span class="n">Copy</span> <span class="n">to</span> <span class="n">clipboardErrorCopied</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928416812_4.png" alt="img" /></p>

<h4 id="312-非阻塞式-io">3.1.2 非阻塞式 I/O</h4>

<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p>

<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929000361_5.png" alt="img" /></p>

<h4 id="313-io-复用">3.1.3 I/O 复用</h4>

<p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>

<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>

<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929444818_6.png" alt="img" /></p>

<h4 id="314-信号驱动-io">3.1.4 信号驱动 I/O</h4>

<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>

<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929553651_7.png" alt="img" /></p>

<h4 id="315-异步-io">3.1.5 异步 I/O</h4>

<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>

<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492930243286_8.png" alt="img" /></p>

<h4 id="316-五大-io-模型比较">3.1.6 五大 I/O 模型比较</h4>

<ul>
  <li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
  <li>异步 I/O：第二阶段应用进程不会阻塞。</li>
</ul>

<p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p>

<p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928105791_3.png" alt="img" /></p>

<h3 id="32-io-复用">3.2 I/O 复用</h3>

<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>

<h4 id="select">select</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>

<ul>
  <li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>
  <li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>
  <li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="n">fd_set</span> <span class="n">fd_in</span><span class="p">,</span> <span class="n">fd_out</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

<span class="c1">// Reset the sets</span>
<span class="n">FD_ZERO</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fd_in</span> <span class="p">);</span>
<span class="n">FD_ZERO</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fd_out</span> <span class="p">);</span>

<span class="c1">// Monitor sock1 for input events</span>
<span class="n">FD_SET</span><span class="p">(</span> <span class="n">sock1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd_in</span> <span class="p">);</span>

<span class="c1">// Monitor sock2 for output events</span>
<span class="n">FD_SET</span><span class="p">(</span> <span class="n">sock2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd_out</span> <span class="p">);</span>

<span class="c1">// Find out which socket has the largest numeric value as select requires it</span>
<span class="kt">int</span> <span class="n">largest_sock</span> <span class="o">=</span> <span class="n">sock1</span> <span class="o">&gt;</span> <span class="n">sock2</span> <span class="o">?</span> <span class="n">sock1</span> <span class="o">:</span> <span class="n">sock2</span><span class="p">;</span>

<span class="c1">// Wait up to 10 seconds</span>
<span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Call the select</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span> <span class="n">largest_sock</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd_in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd_out</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span> <span class="p">);</span>

<span class="c1">// Check if select actually succeed</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="c1">// report error and abort</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="c1">// timeout; no event detected</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">sock1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd_in</span> <span class="p">)</span> <span class="p">)</span>
        <span class="c1">// input event on sock1</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">sock2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd_out</span> <span class="p">)</span> <span class="p">)</span>
        <span class="c1">// output event on sock2</span>
<span class="p">}</span><span class="n">Copy</span> <span class="n">to</span> <span class="n">clipboardErrorCopied</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="poll">poll</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span><span class="n">Copy</span> <span class="n">to</span> <span class="n">clipboardErrorCopied</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>

<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
               <span class="kt">int</span>   <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* file descriptor */</span>
               <span class="kt">short</span> <span class="n">events</span><span class="p">;</span>     <span class="cm">/* requested events */</span>
               <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span>    <span class="cm">/* returned events */</span>
           <span class="p">};</span><span class="n">Copy</span> <span class="n">to</span> <span class="n">clipboardErrorCopied</span>
<span class="c1">// The structure for two events</span>
<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">// Monitor sock1 for input</span>
<span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">sock1</span><span class="p">;</span>
<span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>

<span class="c1">// Monitor sock2 for output</span>
<span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">sock2</span><span class="p">;</span>
<span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLOUT</span><span class="p">;</span>

<span class="c1">// Wait 10 seconds</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span> <span class="p">);</span>
<span class="c1">// Check if poll actually succeed</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="c1">// report error and abort</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="c1">// timeout; no event detected</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// If we detect the event, zero it out so we can reuse the structure</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span> <span class="p">)</span>
        <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// input event on sock1</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span> <span class="p">)</span>
        <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// output event on sock2</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="比较"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=比较">比较</a></h2>

<h3 id="1-功能"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-功能">1. 功能</a></h3>

<p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>

<ul>
  <li>select 会修改描述符，而 poll 不会；</li>
  <li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
  <li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
  <li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>

<h3 id="2-速度"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-速度">2. 速度</a></h3>

<p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>

<h3 id="3-可移植性"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-可移植性">3. 可移植性</a></h3>

<p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>

<h2 id="epoll"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=epoll">epoll</a></h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="err">；</span>
<span class="kt">int</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span><span class="n">Copy</span> <span class="n">to</span> <span class="n">clipboardErrorCopied</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>

<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>

<p>epoll 仅适用于 Linux OS。</p>

<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>

<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre><span class="c1">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span>
<span class="c1">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span>
<span class="kt">int</span> <span class="n">pollingfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span> <span class="mh">0xCAFE</span> <span class="p">);</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">pollingfd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
 <span class="c1">// report error</span>

<span class="c1">// Initialize the epoll structure in case more members are added in future</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="c1">// Associate the connection class instance with the event. You can associate anything</span>
<span class="c1">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span>
<span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">pConnection1</span><span class="p">;</span>

<span class="c1">// Monitor for input, and do not automatically rearm the descriptor after the event</span>
<span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLONESHOT</span><span class="p">;</span>
<span class="c1">// Add the descriptor into the monitoring list. We can do it even if another thread is</span>
<span class="c1">// waiting in epoll_wait - the descriptor will be properly added</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">epoll_ctl</span><span class="p">(</span> <span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">pConnection1</span><span class="o">-&gt;</span><span class="n">getSocket</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ev</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="c1">// report error</span>

<span class="c1">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">pevents</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>

<span class="c1">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span>
<span class="kt">int</span> <span class="n">ready</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span> <span class="n">pollingfd</span><span class="p">,</span> <span class="n">pevents</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10000</span> <span class="p">);</span>
<span class="c1">// Check if epoll actually succeed</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="c1">// report error and abort</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="c1">// timeout; no event detected</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// Check if any events detected</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">pevents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Get back our connection pointer</span>
            <span class="n">Connection</span> <span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">Connection</span><span class="o">*</span><span class="p">)</span> <span class="n">pevents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">handleReadEvent</span><span class="p">();</span>
         <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span><span class="n">Copy</span> <span class="n">to</span> <span class="n">clipboardErrorCopied</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="工作模式"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=工作模式">工作模式</a></h2>

<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>

<h3 id="1-lt-模式"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-lt-模式">1. LT 模式</a></h3>

<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>

<h3 id="2-et-模式"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-et-模式">2. ET 模式</a></h3>

<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>

<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>

<h2 id="应用场景"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=应用场景">应用场景</a></h2>

<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>

<h3 id="1-select-应用场景"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-select-应用场景">1. select 应用场景</a></h3>

<p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>

<p>select 可移植性更好，几乎被所有主流平台所支持。</p>

<h3 id="2-poll-应用场景"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-poll-应用场景">2. poll 应用场景</a></h3>

<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>

<h3 id="3-epoll-应用场景"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-epoll-应用场景">3. epoll 应用场景</a></h3>

<p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>

<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>

<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
:ET