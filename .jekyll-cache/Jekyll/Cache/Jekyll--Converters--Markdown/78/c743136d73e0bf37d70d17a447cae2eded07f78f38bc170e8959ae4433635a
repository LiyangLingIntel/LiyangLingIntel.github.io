I"<blockquote>
  <p>因为并行程序设计课程需要用C/C++进行编程，所以现在需要捡起积灰已久的C++，回头看看，很惭愧很多语法和内部编译细节都忘的差不多了，这里一边重新学习一边积累，希望未来的某天会有所帮助吧。</p>
</blockquote>

<h3 id="c内存分配的方式">C++内存分配的方式</h3>

<ul>
  <li>
    <p><strong>从静态存储区域分配</strong></p>

    <p>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量、静态变量。</p>
  </li>
  <li>
    <p><strong>在栈上创建</strong></p>

    <p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
  </li>
  <li>
    <p><strong>从堆上分配，亦称动态内存分配</strong></p>

    <p>程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由用户决定。</p>
  </li>
</ul>

<h3 id="malloc-vs-calloc-vs--realloc"><code class="highlighter-rouge">malloc()</code> vs <code class="highlighter-rouge">calloc()</code> vs  <code class="highlighter-rouge">realloc()</code></h3>

<p>首先看下函数声明：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">size</span><span class="p">);</span>
<span class="c1">// 在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的</span>
<span class="c1">// 首地址.</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">numElements</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sizeOfElement</span><span class="p">);</span> 
<span class="c1">// 与malloc相似，参数sizeOfElement为申请地址的单位元素长度，numElements为元素个数，即在内存中申请</span>
<span class="c1">// numElements*sizeOfElement字节大小的连续地址空间.</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">newsize</span><span class="p">);</span>  
<span class="c1">// 给一个已经分配了地址的指针重新分配空间，参数ptr为原有的空间地址，newsize是重新申请的地址长度，返回</span>
<span class="c1">// 新的内存指针.</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>区别：</strong></p>

<ul>
  <li>
    <p><code class="highlighter-rouge">malloc()</code>不能初始化所分配的内存空间， 而<code class="highlighter-rouge">calloc()</code>能.</p>

    <p>如果由<code class="highlighter-rouge">malloc()</code>函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0; 反之， 如果这部分内存曾经被分配过， 则其中可能遗留有各种各样的数据. 也就是说，使用<code class="highlighter-rouge">malloc()</code>的程序开始时(内存空间还没有被重新分配)能正常进行，但经过一段时间(内存空间还已经被重新分配)可能会出现问题。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">calloc()</code>会将所分配的内存空间中的每一位都初始化为<strong>0</strong>。</p>

    <p>如果为<strong>字符类型</strong>或<strong>整数类型</strong>的元素分配内存，那么这些元素将保证会被初始化为<strong>0</strong>；</p>

    <p>如果你是为<strong>指针类型</strong>的元素分配内存，那么这些元素通常会被初始化为<strong>空指针</strong>；</p>

    <p>如果为<strong>实型</strong>数据分配内存，则这些元素会被初始化为<strong>浮点型的零</strong>。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">malloc()</code>向系统申请分配指定size个字节的内存空间，返回类型是<code class="highlighter-rouge"> void*</code>类型。</p>

    <p><code class="highlighter-rouge">void*</code>表示未确定类型的指针. C/C++规定，<code class="highlighter-rouge">void*</code> 类型可以强制转换为任何其它类型的指针。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">realloc()</code>可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变。当然，对于缩小，则被缩小的那一部分的内容会丢失。</p>

    <p><code class="highlighter-rouge">realloc()</code>并不保证调整后的内存空间和原来的内存空间保持同一内存地址。相反，<code class="highlighter-rouge">realloc()</code>返回的指针很可能指向一个新的地址。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">realloc()</code>是从堆上分配内存的。当扩大一块内存空间时，<code class="highlighter-rouge">realloc()</code>试图直接从堆上现存的数据后面的那些字节中获得附加的字节；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上。这句话传递的一个重要的信息就是数据可能被移动。</p>
  </li>
</ul>

<p>无论是上述哪一种方法申请的内存最后都需要使用<code class="highlighter-rouge">free</code> 或者 <code class="highlighter-rouge">delete</code>释放，否则就非常容易造成内存泄漏。</p>

<p>这里再顺便简单提一下<code class="highlighter-rouge">free</code>和<code class="highlighter-rouge">delete</code>的区别:</p>

<ul>
  <li>free函数是由C语言继承而来的，是和malloc配对的，而不能和new配对。
free释放内存的和delete可以说是两套代码，它们的逻辑不同，不能混用。
用new申请的就要用delete翻译释放，用malloc申请的就要用free释放。</li>
  <li>还有一个区别， free 只是告诉操作系统回收内存，而delete会先调用类的析构函数，然后才告诉操作系统回收内存</li>
</ul>

:ET