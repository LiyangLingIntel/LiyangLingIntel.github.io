I"i6<p>[TOC]</p>

<h2 id="1-hive--hiveql">1. Hive &amp; HiveQL</h2>

<ul>
  <li><strong>Hive</strong> 是 Hadoop 生态系统中基于HDFS分布式文件系统构建的分布式数据仓库</li>
  <li><strong>HiveQL</strong> 是针对Hive的数据库查询语言，其中封装了MapReduce的查询方法，和传统数据库的差别是：
    <ul>
      <li>Hive是数据仓库，只支持增(<code class="highlighter-rouge">insert</code>)查(<code class="highlighter-rouge">select</code>)，而不支持删(<code class="highlighter-rouge">delete</code>)改(<code class="highlighter-rouge">update</code>)</li>
      <li>增加<strong>分区</strong>的概念，即分区是物理上的“文件夹”，也是逻辑上的“伪列”</li>
      <li>提供用户自定义函数(UDF)的功能，便于开发</li>
      <li>提供视图(view)的概念（和正常数据仓库类似），只能由于查找，不能做插入</li>
    </ul>
  </li>
</ul>

<h2 id="2-使用模式">2. 使用模式</h2>

<h3 id="21-交互模式">2.1 交互模式</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c"># 在终端直接输入hive会进入hive shell直接进行交互，记得每句指令后要加分号;结尾</span>
<span class="nv">$ </span>hive
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="22-终端模式">2.2 终端模式</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c"># -v visualize, 输出执行过程到终端</span>
<span class="c"># -e execute, 执行指定HQL语句</span>
<span class="nv">$ </span>hive <span class="nt">-v</span> <span class="nt">-e</span> <span class="s2">"select * from dbName.tbName limit 10"</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="3-初始设置">3. 初始设置</h2>

<p>以下命令都在Hive shell下执行</p>

<h3 id="31-资源队列">3.1 资源队列</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c"># 在大型集群中，对于不同的项目和任务都会分配指定计算机资源到专属队列中</span>
<span class="c"># 所以在使用Hive时可能需要指定特定资源队列</span>
<span class="o">&gt;</span> SET mapred.job.queue.name<span class="o">=</span>queueName<span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="32-指定数据库">3.2 指定数据库</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="o">&gt;</span> USE databaseName<span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="33-加载udf">3.3 加载UDF</h3>

<p>UDF全程User defined function，指用户基于Java开发的自定义函数。使用前需要将相互依赖的<code class="highlighter-rouge">UDF.jar</code>包一次性载入，否则可能会加载失败。</p>

<h4 id="331-动态加载">3.3.1 动态加载</h4>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="err">&gt;</span><span class="w"> </span><span class="nf">ADD</span><span class="w"> </span><span class="nx">JAR</span><span class="w"> </span><span class="nx">hdfs://nameNode/path/a.jar</span><span class="w"> </span><span class="nx">hdfs://nameNode/path/b.jar</span><span class="p">;</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="nf">CREATE</span><span class="w"> </span><span class="nx">TEMPORARY</span><span class="w"> </span><span class="nx">FUNCTION</span><span class="w"> </span><span class="nx">udfFunc1</span><span class="w"> </span><span class="nx">as</span><span class="w"> </span><span class="s1">'com.abc.udf1'</span><span class="p">;</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="nf">CREATE</span><span class="w"> </span><span class="nx">TEMPORARY</span><span class="w"> </span><span class="nx">FUNCTION</span><span class="w"> </span><span class="nx">udfFunc2</span><span class="w"> </span><span class="nx">as</span><span class="w"> </span><span class="s1">'com.abc.udf2'</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>这种方式的好处是比较灵活，问题在于加载的UDF只存在于当前Session中，断开对话就消失了，下次使用还需要重新加载。</p>

<h4 id="332-修改hive-sitexml文件">3.3.2 修改hive-site.xml文件</h4>

<p>另一种方法是，修改参数<code class="highlighter-rouge">hive.aux.jars.path</code>的值指向UDF文件所在的路径，该参数需要手动添加到hive-site.xml文件中。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nt">&lt;property&gt;</span>
<span class="nt">&lt;name&gt;</span>hive.aux.jars.path<span class="nt">&lt;/name&gt;</span>
<span class="nt">&lt;value&gt;</span>file:///jarpath/all_new1.jar,file:///jarpath/all_new2.jar<span class="nt">&lt;/value&gt;</span>
<span class="nt">&lt;/property&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="333-创建auxlib目录">3.3.3 创建auxlib目录</h4>

<p>比较简答的一种方法是，在<code class="highlighter-rouge">${HIVE_HOME}</code>下创建auxlib目录，将UDF文件放到该目录中，这样hive在启动时会将其中的jar文件加载到classpath中。</p>

<h2 id="4-表操作">4. 表操作</h2>

<h3 id="41-ddl-数据定义语言">4.1 DDL 数据定义语言</h3>

<h4 id="411-create-创建">4.1.1 <code class="highlighter-rouge">create</code> 创建</h4>

<p>下面有几种常见造表操作</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="c1">-- 造无分区表</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">test_table</span><span class="p">(</span>
  <span class="n">id</span> <span class="nb">int</span><span class="p">,</span>
  <span class="n">name</span> <span class="n">string</span><span class="p">,</span>
  <span class="n">age</span> <span class="nb">int</span><span class="p">,</span>
  <span class="n">tel</span> <span class="n">string</span>
<span class="p">)</span> <span class="k">ROW</span> <span class="n">FORMAT</span> <span class="n">DELIMITED</span>
<span class="n">FIELDS</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="nv">"</span><span class="se">\0</span><span class="nv">01"</span> 	<span class="c1">-- 列分隔符</span>
<span class="n">LINES</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="nv">"</span><span class="se">\n</span><span class="nv">"</span> 			<span class="c1">-- 行分隔符</span>
<span class="k">ROW</span> <span class="n">FORMAT</span> <span class="n">SERDE</span> <span class="nv">"org.apache.hadoop.hive.ql.io.orc.OrcSerde"</span>		<span class="c1">-- 序列化格式</span>
<span class="n">STORED</span> <span class="k">AS</span>
<span class="n">INPUTFORMAT</span> <span class="nv">"org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"</span>		<span class="c1">-- input格式</span>
<span class="n">OUTPUTFORMAT</span> <span class="nv">"org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"</span><span class="p">;</span> <span class="c1">-- output格式</span>

<span class="c1">-- 造分区表</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">test_table</span><span class="p">(</span>
  <span class="n">id</span> <span class="nb">int</span><span class="p">,</span>
  <span class="n">name</span> <span class="n">string</span><span class="p">,</span>
  <span class="n">age</span> <span class="nb">int</span><span class="p">,</span>
  <span class="n">tel</span> <span class="n">string</span>
<span class="p">)</span> 
<span class="n">PARTITIONED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">y</span> <span class="n">string</span><span class="p">,</span> <span class="n">m</span> <span class="n">string</span><span class="p">,</span> <span class="n">d</span> <span class="n">string</span><span class="p">)</span>
<span class="k">ROW</span> <span class="n">FORMAT</span> <span class="n">DELIMITED</span>
<span class="n">STORED</span> <span class="k">AS</span> <span class="n">TEXTFILE</span><span class="p">;</span> 		<span class="c1">-- 内置基本文件格式</span>

<span class="c1">-- 复制空表结构</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">newTable</span> <span class="k">LIKE</span> <span class="n">oldTable</span><span class="p">;</span>

<span class="c1">-- 通过已有表和数据造表并插入空值</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">newTable</span> <span class="k">AS</span> <span class="k">SELECT</span> <span class="k">key</span><span class="p">,</span> <span class="n">features</span> <span class="k">FROM</span> <span class="n">oldTable</span> <span class="k">WHERE</span> <span class="n">y</span><span class="o">=</span><span class="s1">'2019'</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>从已有表生成<strong>create-table-as-select(CTAS)</strong></p>

<ul>
  <li>CTAS创建的表是原子性的，这意味着，只有当该表所有查询完成后，用户才能看到完整的结果表。</li>
  <li>CTAS唯一的限制是目标表：即目标表不能是有个有分区的表，也不能是外部表。</li>
</ul>

<p>三种内置存储格式</p>

<ul>
  <li><code class="highlighter-rouge">TEXTFILE</code> 是最普通的文件存储格式，内容可以直接查看。</li>
  <li><code class="highlighter-rouge">SEQUENCENFILE</code> 基于行存储，将表中的数据以二进制格式编码，并且支持数据压缩，可以节省存储空间。</li>
  <li><code class="highlighter-rouge">RCFILE</code> 基于列存储，将表中的数据以二进制格式编码，并且支持压缩。 因为列值重复多，所以压缩效率高。占用磁盘存储空间小，io压力小。对包含大量字段的表而言，更适合RCFILE存储。</li>
</ul>

<h4 id="412-drop-删除">4.1.2 <code class="highlighter-rouge">drop</code> 删除</h4>

<p>常见删表操作</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">testTable</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>被 <code class="highlighter-rouge">drop</code> 或者 <code class="highlighter-rouge">insert overwrite</code> 的表会暂时被移动到HDFS的 <code class="highlighter-rouge">hdfs://namenode/tmp/username/taskid/</code> 路径下以供恢复。</p>

<h4 id="413-alter-更改">4.1.3 <code class="highlighter-rouge">alter</code> 更改</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="c1">-- 增加分区</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">testTable</span> <span class="k">ADD</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span><span class="p">)</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2016'</span><span class="p">);</span>

<span class="c1">-- 增加分区，多个分区需要指定前后顺序</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">testTable</span> <span class="k">ADD</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="s1">'03'</span><span class="p">)</span> <span class="k">location</span> <span class="s1">'/y=2017/m=03'</span><span class="p">;</span>

<span class="c1">-- 删除分区</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">testTable</span> <span class="k">DROP</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span><span class="p">)</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2016'</span><span class="p">);</span>

<span class="c1">-- 表重命名</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">old_table</span> <span class="k">RENAME</span> <span class="k">TO</span> <span class="n">new_table</span><span class="p">;</span>

<span class="c1">-- 添加列</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">testTable</span> <span class="k">ADD</span> <span class="n">COLUMNS</span> <span class="p">(</span><span class="n">extra_col1</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'New Col1'</span><span class="p">,</span>
                                   <span class="n">extra_col2</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'New Col2'</span><span class="p">);</span>                                
<span class="c1">-- 替换全部列</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">testTable</span> <span class="k">REPLACE</span> <span class="n">COLUMNS</span> <span class="p">(</span><span class="n">new_col1</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'New Col1'</span><span class="p">,</span>
                                       <span class="n">new_col2</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'New Col2'</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="414-load-装载数据">4.1.4 <code class="highlighter-rouge">load</code> 装载数据</h4>

<p><code class="highlighter-rouge">load</code>从外部文件载入数据并转化为Hive的分布式数据文件。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">-- 往无分区表装载并覆盖</span>
<span class="k">LOAD</span> <span class="k">DATA</span> <span class="n">INPATH</span> <span class="s1">'path/data.csv'</span> <span class="n">OVERWRITE</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">test_table</span><span class="p">;</span>

<span class="c1">-- 往指定分区装载并覆盖</span>
<span class="k">LOAD</span> <span class="k">DATA</span> <span class="n">INPATH</span> <span class="s1">'path/data.csv'</span> <span class="n">OVERWRITE</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">test_table</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2019'</span><span class="p">);</span>

<span class="c1">-- 往指定分区装载并追加</span>
<span class="k">LOAD</span> <span class="k">DATA</span> <span class="n">INPATH</span> <span class="s1">'path/data.csv'</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">test_table</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2019'</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="42-dml-数据操作语言">4.2 DML 数据操作语言</h3>

<h4 id="421-select-查询">4.2.1 <code class="highlighter-rouge">select</code> 查询</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="c1">-- 例子：统计不同年龄/性别组的人数</span>
<span class="k">SELECT</span> <span class="n">b</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">sex</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> 
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">table_1</span><span class="p">)</span> <span class="n">a</span>
<span class="k">JOIN</span> 
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">table_2</span><span class="p">)</span> <span class="n">b</span>
<span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">sex</span> <span class="k">FROM</span> <span class="n">table_3</span><span class="p">)</span> <span class="k">c</span>
<span class="k">ON</span> <span class="n">b</span><span class="p">.</span><span class="n">employee_id</span><span class="o">=</span><span class="k">c</span><span class="p">.</span><span class="n">employee_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">b</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">sex</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">b</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">sex</span> <span class="k">DESC</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">select</code> 嵌套查询会影响性能，有时候可以提速，有时候会降速，取决于mapper-reducer的分配机制。</p>

<h5 id="查询关键词">查询关键词</h5>

<ul>
  <li>
    <p><code class="highlighter-rouge">distinct</code> 去重
<code class="highlighter-rouge">distinct</code> 对结果集去重，一般会启用MapReduce并行去重。<code class="highlighter-rouge">distinct</code> 一般会对全部选择字段去重，并不能针对其中部分字段去重。</p>

    <p><code class="highlighter-rouge">count distinct</code> 去重统计会将reducer的数量强制限制为1，因而应该写为子查询提高效率。</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">-- 罗列不同性别和年龄的组合</span>
<span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">sex</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
  
<span class="c1">-- 使用子查询优化，罗列不同性别和年龄的组合</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">sex</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">)</span> <span class="n">tb</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">group by</code> 分组
<code class="highlighter-rouge">group by</code>条件可以使字段也可以是函数结果，会将数据分组再在每组内分别执行聚合函数。
<code class="highlighter-rouge">group by</code>依赖的字段必须是已有的或者在子查询内的，不能是在同一层查询的字段别名。
<code class="highlighter-rouge">group by</code>不能和<code class="highlighter-rouge">distinc</code>同时使用。</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">-- 按性别、年龄分组并统计人数</span>
<span class="k">SELECT</span> <span class="n">sex</span><span class="p">,</span> <span class="n">age</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">sex</span><span class="p">,</span> <span class="n">age</span><span class="p">;</span>
  
<span class="c1">-- 随机分组并统计平均年龄</span>
<span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="k">CAST</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">10</span> <span class="k">AS</span> <span class="nb">int</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">order by</code> 与 <code class="highlighter-rouge">sort by</code> 排序
<code class="highlighter-rouge">order by</code>会对输出做全局排序，因此会触发一个reducer，当输出规模较大是，需要较长计算时间和存储空间。
<code class="highlighter-rouge">sort by</code>不是全局排序，其在数据进入reducer之前完成排序。可以通过<code class="highlighter-rouge">set mapred.reduce.tasks=&lt;numer&gt;</code>设置reducer个数。结果集在单个reducer内有序但对全局未必有序，所以常辅以<code class="highlighter-rouge">order by</code>优化性能。</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">-- 按年龄全局倒序排序曲最年迈的10个人</span>
<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
  
<span class="c1">-- 通过sort by预筛选而优化order by性能，同时避免数据过大而无法order by</span>
<span class="k">SET</span> <span class="n">mapred</span><span class="p">.</span><span class="n">reduce</span><span class="p">.</span><span class="n">tasks</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> 
<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="n">SORT</span> <span class="k">BY</span> <span class="n">age</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span> <span class="n">t</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">age</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">limit</code> 限制
 <code class="highlighter-rouge">limit</code> 结果集的顺序是随机的，和存储文件的顺序有关。
<code class="highlighter-rouge">limit</code> 的执行顺序亚于<code class="highlighter-rouge">order by</code>。</p>
  </li>
</ul>

<h4 id="422-insert-插入">4.2.2 <code class="highlighter-rouge">insert</code> 插入</h4>

<p><code class="highlighter-rouge">insert</code>的数据源是Hive内已经存在的表。</p>

<p><code class="highlighter-rouge">insert into</code> 是在文件末尾追加数据，而<code class="highlighter-rouge">insert overwrite</code>是覆盖全部数据文件。</p>

<p>讲一个表的数据拆分到多个分区需要注意合理使用<code class="highlighter-rouge">insert</code>语法，避免多次扫描全表。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="c1">-- 增加数据</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">test_table</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">source_table</span><span class="p">;</span>

<span class="c1">-- 覆盖原分区的数据</span>
<span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="k">TABLE</span> <span class="n">test_table</span>
<span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">source_table</span><span class="p">;</span>

<span class="c1">-- 一次扫描多路输出</span>
<span class="k">FROM</span> <span class="n">source_table</span> <span class="n">st</span>
<span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="k">TABLE</span> <span class="n">target_table</span>
		<span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span> <span class="k">AND</span> <span class="n">m</span><span class="o">=</span><span class="s1">'03'</span><span class="p">)</span>
		<span class="k">SELECT</span> <span class="o">*</span> <span class="k">WHERE</span> <span class="n">st</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span> <span class="k">AND</span> <span class="n">st</span><span class="p">.</span><span class="n">m</span><span class="o">=</span><span class="s1">'03'</span>
<span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="k">TABLE</span> <span class="n">target_table</span>
		<span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span> <span class="k">AND</span> <span class="n">m</span><span class="o">=</span><span class="s1">'04'</span><span class="p">)</span>
		<span class="k">SELECT</span> <span class="o">*</span> <span class="k">WHERE</span> <span class="n">st</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span> <span class="k">AND</span> <span class="n">st</span><span class="p">.</span><span class="n">m</span><span class="o">=</span><span class="s1">'04'</span>
<span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="k">TABLE</span> <span class="n">target_table</span>
		<span class="n">PARTITION</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span> <span class="k">AND</span> <span class="n">m</span><span class="o">=</span><span class="s1">'05'</span><span class="p">)</span>
		<span class="k">SELECT</span> <span class="o">*</span> <span class="k">WHERE</span> <span class="n">st</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="s1">'2017'</span> <span class="k">AND</span> <span class="n">st</span><span class="p">.</span><span class="n">m</span><span class="o">=</span><span class="s1">'05'</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="423-join-连接">4.2.3 <code class="highlighter-rouge">join</code> 连接</h4>

<h5 id="性能优化">性能优化</h5>

<ul>
  <li>Hive的 <code class="highlighter-rouge">join</code> 只支持但条件或多条件的等值 <code class="highlighter-rouge">=</code> 关联，不支持 <code class="highlighter-rouge">or</code> 关联。</li>
  <li><code class="highlighter-rouge">join</code> 的结果集不能有重名字段。</li>
  <li>reducer 会缓存 <code class="highlighter-rouge">join</code> 序列中除了最后一个表的所有表的记录，再通过最后一个表将结果序列化到文件系统，因此实践中应该把最大的那个表写在最后，否则会因为缓存浪费大量内存。</li>
  <li>如果两张大宽表都有大量字段，但结果集仅保留少量字段，则建议用子查询优先筛选字段，避免占用太多缓存甚至是OOM任务失败。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">-- 通过子查询过滤字段</span>
<span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">sex</span> <span class="k">FROM</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">table_1</span><span class="p">)</span> <span class="n">a</span>
<span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span><span class="err">，</span><span class="n">employee_id</span><span class="err">，</span><span class="n">age</span> <span class="k">FROM</span> <span class="n">table_2</span><span class="p">)</span> <span class="n">b</span>
<span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">sex</span> <span class="k">FROM</span> <span class="n">table_3</span><span class="p">)</span> <span class="k">c</span>
<span class="k">ON</span> <span class="n">b</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">employee_id</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>如果所有表之间没有公共关联键，则会触发多个MR stage依次执行，如果所有表之间存在同一公共关联键，则用最大表为左表可以让MR stage并行执行。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">-- Parallel Join</span>
<span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">sex</span> <span class="k">FROM</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">table_1</span><span class="p">)</span> <span class="n">a</span>
<span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span><span class="err">，</span><span class="n">age</span> <span class="k">FROM</span> <span class="n">table_2</span><span class="p">)</span> <span class="n">b</span>
<span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">sex</span> <span class="k">FROM</span> <span class="n">table_3</span><span class="p">)</span> <span class="k">c</span>
<span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">join</code> 之前需要确保关联键是否去重，是不是刻意保留非去重结果，要警惕数据倾斜的发生。</li>
</ul>

<h5 id="数据倾斜">数据倾斜</h5>

<p>如果两张 10^8^ 数量级的表未对关联键去重，且每张表有10%的数据的关联键为空，则此部分脏数据就会形成10^14^ 数据量的文件，而导致Reducer阶段始终卡在99%。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">-- 对关联键进行非NULL非空过滤，避免数据倾斜</span>
<span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">sex</span> <span class="k">FROM</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="k">distinct</span> <span class="n">id</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">table_1</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">AND</span> <span class="n">id</span> <span class="o">&lt;&gt;</span> <span class="s1">''</span><span class="p">)</span> <span class="n">a</span>
<span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="k">distinct</span> <span class="n">id</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">table_2</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">AND</span> <span class="n">id</span> <span class="o">&lt;&gt;</span> <span class="s1">''</span><span class="p">)</span> <span class="n">b</span>
<span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="3种类型的-join">3种类型的 <code class="highlighter-rouge">join</code></h5>

<ul>
  <li><code class="highlighter-rouge">join</code> : Hive 的 <code class="highlighter-rouge">join</code> 默认是 <code class="highlighter-rouge">inner join</code> , 找出左右都可匹配的记录。</li>
  <li><code class="highlighter-rouge">left join </code> : 左连接，以左边表为准，逐条去右边表找可匹配的字段，如果有多条会依次列出。</li>
  <li><code class="highlighter-rouge">full outer join</code> : 包含两个表的连接结果，左表缺失或右表缺失的数据会填充NULL。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">-- 左右两表连接取并集的sql模板</span>
<span class="k">SELECT</span> <span class="n">nvl</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">sex</span> <span class="k">FROM</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">table1</span><span class="p">)</span> <span class="n">a</span>
<span class="k">FULL</span> <span class="k">OUTER</span> <span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">sex</span> <span class="k">FROM</span> <span class="n">table2</span><span class="p">)</span> <span class="n">b</span>
<span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="424-union-合并">4.2.4 <code class="highlighter-rouge">union</code> 合并</h4>

<p><code class="highlighter-rouge">union</code> 与 <code class="highlighter-rouge">union all</code> 均基于列合并多张表的数据，所合并的列格式必须完全一致。</p>

<p><code class="highlighter-rouge">union</code> 过程中会去重并降低效率，而 <code class="highlighter-rouge">union all</code> 直接追加数据</p>

<p><code class="highlighter-rouge">union</code> 前后是两段 <code class="highlighter-rouge">select</code> 语句而非结果集</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="c1">-- 不去重合并两张表的数据</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">union_table</span> <span class="k">as</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span>
<span class="p">(</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table_1</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table_2</span>
<span class="p">)</span><span class="n">t</span><span class="p">;</span>

<span class="c1">-- 针对两个限制行数的子表进行union需要额外嵌套select</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">union_table</span> <span class="k">as</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span>
<span class="p">(</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table_1</span> <span class="k">LIMIT</span> <span class="mi">100</span><span class="p">)</span> <span class="n">tb1</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table_2</span> <span class="k">LIMIT</span> <span class="mi">200</span><span class="p">)</span> <span class="n">tb2</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="425-导出数据">4.2.5 导出数据</h4>

<p>导出数据可以通过命令行模式或者交互模式实现</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">-- 交互模式</span>
<span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="k">LOCAL</span> <span class="n">DIRECTORY</span> <span class="s1">'path/data.csv'</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">LIMIT</span> <span class="mi">100</span><span class="p">;</span>

<span class="c1">-- 命令行模式</span>
<span class="n">hive</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">e</span> <span class="nv">"SELECT * FROM test_table LIMIT 100;"</span> <span class="o">&gt;</span><span class="n">path</span><span class="o">/</span><span class="k">data</span><span class="p">.</span><span class="n">csv</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>（*）命令行模式中，会出现secureCRT中hive的显示错误（缺少空格，tab，数据黏连，数据缺少等），交互模式可以避免该问题。</p>

<h3 id="43-常用函数汇总">4.3 常用函数汇总</h3>

<h4 id="431--比较">4.3.1 <code class="highlighter-rouge">!=</code>/<code class="highlighter-rouge">&lt;&gt;</code>/<code class="highlighter-rouge">=</code> 比较</h4>

<p>针对string类型的比较适合用 <code class="highlighter-rouge">&lt;&gt;</code> 不等与 <code class="highlighter-rouge">=</code> 相等， 针对数值类型的比较适合用 <code class="highlighter-rouge">!=</code> 与 <code class="highlighter-rouge">=</code>。</p>

<p>判断是否是NULL适合直接用 <code class="highlighter-rouge">is null</code> 和 <code class="highlighter-rouge">is not null</code></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">-- 过滤脏姓名数据</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table1</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">&lt;&gt;</span> <span class="s1">''</span> <span class="k">AND</span> <span class="n">name</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>

<span class="c1">-- 过滤脏年龄数据</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table2</span> <span class="k">WHERE</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="k">AND</span> <span class="n">age</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="432-字符串函数">4.3.2 字符串函数</h4>

<h5 id="基本函数">基本函数</h5>

<ul>
  <li><code class="highlighter-rouge">concat(str1, str2)</code> 进行字符串合并。</li>
  <li><code class="highlighter-rouge">length(str)</code> 返回字符串长度。</li>
  <li><code class="highlighter-rouge">substr(str,0,12)</code> 截取字符串从0位开始的12个字符。</li>
</ul>

<h5 id="匹配与正则函数">匹配与正则函数</h5>

<ul>
  <li><code class="highlighter-rouge">like</code> 做普通文本匹配， <code class="highlighter-rouge">rlike</code> 做正则匹配，且在HIve2上不在支持针对int类型的匹配。</li>
  <li><code class="highlighter-rouge">regexp_replace</code> 做正则替换， <code class="highlighter-rouge">regexp_extract</code> 做正则匹配。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">-- 获取基金有关数据</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">WHERE</span> <span class="n">product_type</span> <span class="k">LIKE</span> <span class="nv">"%基金%"</span><span class="err">；</span>

<span class="c1">-- 将"2017-04-01 00:00:00"格式的时间先提取年月日再去除"-"符号，最后转为int</span>
<span class="c1">-- 0对应完整匹配结果，1/2/3则对应第1/2/3和()内的匹配结果</span>
<span class="k">SELECT</span> <span class="k">CAST</span><span class="p">(</span><span class="n">regexp_replace</span><span class="p">(</span><span class="n">regexp_extract</span><span class="p">(</span><span class="n">reg_time</span><span class="p">,</span><span class="nv">"([0-9]+)-([0-9]+)-([0-9]+)"</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="nv">"-"</span><span class="p">,</span><span class="nv">""</span><span class="p">)</span> <span class="k">AS</span> <span class="nb">int</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="433-countsumavgmaxmin-聚合函数">4.3.3 <code class="highlighter-rouge">count</code>/<code class="highlighter-rouge">sum</code>/<code class="highlighter-rouge">avg</code>/<code class="highlighter-rouge">max</code>/<code class="highlighter-rouge">min</code> 聚合函数</h4>

<h5 id="基本使用">基本使用</h5>

<p>聚合函数在同一层查询中可以组合使用，但不可能互相嵌套使用。</p>

<p>如果需要实现诸如max(avg(feature))的效果，则需要使用嵌套的 <code class="highlighter-rouge">select</code>。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">-- 简单统计年龄分布</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">AVG</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">as</span> <span class="n">avg_age</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">as</span> <span class="n">max_age</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>

<span class="c1">-- 统计不同性别的年龄分布</span>
<span class="k">SELECT</span> <span class="n">sex</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">AVG</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">as</span> <span class="n">avg_age</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">as</span> <span class="n">max_age</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">sex</span><span class="err">；</span>

<span class="c1">-- 结合case when使用统计有效数据量</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">income</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="k">NULL</span> <span class="k">END</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">income_record</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="count-与-sum-的区别"><code class="highlighter-rouge">count</code> 与 <code class="highlighter-rouge">sum</code> 的区别</h5>

<p><code class="highlighter-rouge">sum</code> 针对所有数值求和， <code class="highlighter-rouge">count</code> 将所有非NULL值记为1后统计。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">-- 针对Value字段的有值率统计</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">IF</span><span class="p">(</span><span class="n">value</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="k">NULL</span><span class="p">))</span><span class="o">/</span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="434-case-条件函数">4.3.4 <code class="highlighter-rouge">case</code> 条件函数</h4>

<p><code class="highlighter-rouge">case</code> 函数通常格式为 <code class="highlighter-rouge">(case when condition1 then value1 else null end)</code> , 其中<code class="highlighter-rouge">else</code> 默认条件可省，<code class="highlighter-rouge">end</code> 关键词必不可省。</p>

<p><code class="highlighter-rouge">case when</code> 中不能包含聚合函数，否则会报错。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="c1">-- 收入区间分组</span>
<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span>
<span class="p">(</span><span class="k">CASE</span>
 <span class="k">WHEN</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">50000</span> <span class="k">THEN</span> <span class="s1">'0~5万'</span>
 <span class="k">WHEN</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">50000</span> <span class="k">AND</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1000000</span> <span class="k">THEN</span> <span class="s1">'5~10万'</span>
 <span class="k">WHEN</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">100000</span> <span class="k">AND</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1500000</span> <span class="k">THEN</span> <span class="s1">'10~15万'</span>
 <span class="k">WHEN</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">150000</span> <span class="k">AND</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2000000</span> <span class="k">THEN</span> <span class="s1">'15~20万'</span>
 <span class="k">WHEN</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">200000</span> <span class="k">AND</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2500000</span> <span class="k">THEN</span> <span class="s1">'20~25万'</span>
 <span class="k">WHEN</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">250000</span> <span class="k">AND</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3000000</span> <span class="k">THEN</span> <span class="s1">'25~30万'</span>
 <span class="k">WHEN</span> <span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">as</span> <span class="nb">float</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">300000</span> <span class="k">THEN</span> <span class="s1">'30万以上'</span>
 <span class="k">ELSE</span> <span class="k">NULL</span> <span class="k">END</span><span class="p">)</span>
 <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="435-if-条件函数">4.3.5 <code class="highlighter-rouge">if</code> 条件函数</h4>

<p><code class="highlighter-rouge">if</code> 函数是简化版的 <code class="highlighter-rouge">case</code> 函数，且可以通过嵌套实现多分类。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">-- 将年龄分为四段</span>
<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">IF</span><span class="p">(</span><span class="n">age</span><span class="o">&gt;</span><span class="mi">50</span><span class="p">,</span> <span class="n">IF</span><span class="p">(</span><span class="n">age</span><span class="o">&gt;</span><span class="mi">75</span><span class="p">,</span><span class="nv">"晚年"</span><span class="p">,</span><span class="nv">"中老年"</span><span class="p">),</span><span class="n">IF</span><span class="p">(</span><span class="n">age</span><span class="o">&gt;</span><span class="mi">25</span><span class="p">,</span><span class="nv">"青壮年"</span><span class="p">,</span><span class="nv">"青少年"</span><span class="p">))</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="436-in-范围函数">4.3.6 <code class="highlighter-rouge">in</code> 范围函数</h4>

<p>HIve不支持在 <code class="highlighter-rouge">in</code> 函数嵌套 <code class="highlighter-rouge">select</code> 语句。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">-- 提取已知性别的数据</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">test_table</span> <span class="k">WHERE</span> <span class="n">sex</span> <span class="k">IN</span><span class="p">(</span><span class="nv">"M"</span><span class="p">,</span><span class="nv">"F"</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="437-where-过滤条件">4.3.7 <code class="highlighter-rouge">where</code> 过滤条件</h4>

<p><code class="highlighter-rouge">where</code> 过滤条件针对 <code class="highlighter-rouge">group by</code> 前的结果集筛选， 优先级高于 <code class="highlighter-rouge">group by</code></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">-- 统计不同公司的男性平均年龄</span>
<span class="k">SELECT</span> <span class="n">company</span><span class="p">,</span> <span class="k">AVG</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span>
<span class="k">WHERE</span> <span class="n">sex</span> <span class="o">=</span> <span class="nv">"M"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">company</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="438-having-过滤条件">4.3.8 <code class="highlighter-rouge">having</code> 过滤条件</h4>

<p><code class="highlighter-rouge">having</code> 过滤条件针对 <code class="highlighter-rouge">group by</code> 后的结果集筛选，优先级低于 <code class="highlighter-rouge">group by</code></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">-- 统计不同公司的男性平均年龄，且仅保留平均年龄在50岁以上的公司</span>
<span class="k">SELECT</span> <span class="n">company</span><span class="p">,</span> <span class="k">AVG</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span>
<span class="k">WHERE</span> <span class="n">sex</span> <span class="o">=</span> <span class="nv">"M"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">company</span>
<span class="k">HAVING</span> <span class="n">AVGA</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="439-nvl-空值填充函数">4.3.9 <code class="highlighter-rouge">nvl</code> 空值填充函数</h4>

<p><code class="highlighter-rouge">NVL(string1, replace_with)</code> 用法，如果string1为NULL，则<code class="highlighter-rouge">nvl</code> 函数返回replace_with的值，否则返回string1的值。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">-- 无收入的客户默认值为0</span>
<span class="k">SELECT</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">NVL</span><span class="p">(</span><span class="n">salary</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">AS</span> <span class="n">salary</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4310-cast-类型转换">4.3.10 <code class="highlighter-rouge">cast</code> 类型转换</h4>

<p><code class="highlighter-rouge">cast as</code> 常用于string/int/double之间的类型转换</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">-- 把string类型保存的数字还原为int</span>
<span class="k">SELECT</span> <span class="k">CAST</span><span class="p">(</span><span class="n">value_string</span> <span class="k">as</span> <span class="nb">INT</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4311-row_number-编号函数">4.3.11 <code class="highlighter-rouge">row_number</code> 编号函数</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">-- 按照c2字段倒叙编号</span>
<span class="k">SELECT</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">OVER</span><span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">c2</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">AS</span> <span class="n">row_num</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>

<span class="c1">-- 按照c1字段分组后再按c2字段倒叙编号</span>
<span class="k">SELECT</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">OVER</span><span class="p">(</span><span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">c1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">c2</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">AS</span> <span class="n">row_num</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4312-percentile-百分位函数">4.3.12 <code class="highlighter-rouge">percentile</code> 百分位函数</h4>

<p>如果只查询一个分位, 则 <code class="highlighter-rouge">percentile</code> 的返回结果是数值, 如果查询多个分位, 则结果是string类型的array.</p>

<p>如果不加 <code class="highlighter-rouge">where</code> 条件限定, 则 <code class="highlighter-rouge">percentile</code> 的计算过程包含0值, 往往会造成结果偏移.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">-- 获取income字段的10个分位值</span>
<span class="k">SELECT</span> <span class="n">percentile</span><span class="p">(</span><span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">AS</span> <span class="nb">int</span><span class="p">),</span> <span class="n">ARRAY</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="k">AS</span> <span class="n">income_percentiles</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>

<span class="c1">-- 获取income段字Top10%的阈值</span>
<span class="k">SELECT</span> <span class="n">percentile</span><span class="p">(</span><span class="k">CAST</span><span class="p">(</span><span class="n">income</span> <span class="k">AS</span> <span class="nb">int</span><span class="p">),</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="p">))</span> <span class="k">AS</span> <span class="n">income_top10p_threshold</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4313-to_date-时间函数">4.3.13 <code class="highlighter-rouge">to_date</code> 时间函数</h4>

<p><code class="highlighter-rouge">to_date()</code> 时间函数可以把时间字符串转换成时间类型, 再计算时间差</p>

<p>常用日期提取函数包括 <code class="highlighter-rouge">year(dstr)</code>/<code class="highlighter-rouge">month(dstr)</code>/<code class="highlighter-rouge">day(dstr)</code>/<code class="highlighter-rouge">hour(dstr)</code>/<code class="highlighter-rouge">minute(dstr)</code>/<code class="highlighter-rouge">second(dstr)</code></p>

<p>日期运算函数包括 <code class="highlighter-rouge">datediff(enddate,startdate)</code>/<code class="highlighter-rouge">date_sub(startdate,days)</code>/<code class="highlighter-rouge">date_add(startdate,days)</code></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">-- 转换时间数据的格式</span>
<span class="k">SELECT</span> <span class="n">to_date</span><span class="p">(</span><span class="nv">"1970-01-01 00:00"</span><span class="p">)</span><span class="k">SELECT</span> <span class="n">to_date</span><span class="p">(</span><span class="nv">"1970-01-01 00:00:00"</span><span class="p">)</span> <span class="k">AS</span> <span class="n">start_time</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>

<span class="c1">-- 计算所有数据到当前时间的天数差</span>
<span class="k">SELECT</span> <span class="n">datediff</span><span class="p">(</span><span class="n">to_date</span><span class="p">(</span><span class="n">from_unixtime</span><span class="p">(</span><span class="n">unix_timestamp</span><span class="p">())),</span><span class="n">record_date</span><span class="p">)</span> <span class="k">from</span> <span class="n">test_table</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4314-split字符串分隔函数">4.3.14 <code class="highlighter-rouge">split</code>字符串分隔函数</h4>

<p><code class="highlighter-rouge">split(str,regex)</code> 函数用于将string类型数据按regex提取, 分隔后转换为array.</p>

<p>数据拆分为多个列.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">-- 以","为分隔符分隔字符串, 并转化为array</span>
<span class="k">SELECT</span> <span class="n">split</span><span class="p">(</span><span class="nv">"1,2,3"</span><span class="p">,</span> <span class="nv">","</span><span class="p">)</span> <span class="k">AS</span> <span class="n">value_array</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>

<span class="c1">-- 结合array index, 将原始字符串分割成3列</span>
<span class="k">SELECT</span> <span class="n">value_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">AS</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">AS</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">AS</span> <span class="n">value3</span> <span class="k">FROM</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">split</span><span class="p">(</span><span class="nv">"1,2,3"</span><span class="p">,</span> <span class="nv">","</span><span class="p">)</span> <span class="k">AS</span> <span class="n">value_array</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">)</span><span class="n">t</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4315-explode-转置函数">4.3.15 <code class="highlighter-rouge">explode</code> 转置函数</h4>

<p><code class="highlighter-rouge">explode</code> 转置单列使用时可以把单列数据拆分成多行.</p>

<p><code class="highlighter-rouge">explode</code> 转置单列并保留其他列时需要结合 <code class="highlighter-rouge">lateral view</code> 使用.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">-- array(1,2,3)变成了3列</span>
<span class="k">SELECT</span> <span class="n">explode</span><span class="p">(</span><span class="n">ARRAY</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="k">FROM</span> <span class="n">test_table</span><span class="p">;</span>

<span class="c1">-- 保留主键列, 并将存储array(1,2,3)的array_col列转置</span>
<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">exploded_col</span> <span class="k">FROM</span> <span class="n">source_table</span>
<span class="k">LATERAL</span> <span class="k">VIEW</span> <span class="n">explode</span><span class="p">(</span><span class="n">array_col</span><span class="p">)</span> <span class="n">view_alias</span> <span class="k">AS</span> <span class="n">exploded_col</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4316-with-cube-分析功能">4.3.16 <code class="highlighter-rouge">with cube</code> 分析功能</h4>

<p><code class="highlighter-rouge">with cube</code> 功能实现了笛卡尔积运算</p>

<p>如果对(a,b,c)字段组进行 <code class="highlighter-rouge">group by with cube</code>, 则相当于 <code class="highlighter-rouge">(a,b,c),(a,b),(a,c),(b,c),(a),(b),(c),()</code> 这8种情况分别聚合统计.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">-- 统计a,b,c这仨个字段在所有组合下的记录数</span>
<span class="k">SELECT</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span><span class="p">,</span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">test_table</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span> <span class="k">WITH</span> <span class="k">CUBE</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="5-其他操作">5. 其他操作</h2>

<h3 id="51-数据迁移">5.1 数据迁移</h3>

<ul>
  <li>
    <p>在新路径下创建一张相同结构的表，字段结构、<code class="highlighter-rouge">serde format</code> 和 <code class="highlighter-rouge">stored as</code> 类型必须完全一致</p>

    <pre><code class="language-mysql">create table migrated_table(
  id string,
  number int,
  key_double double,
  key_string string
) row format delimited fields terminated by '\t';
</code></pre>

    <p>这种方式一般属于其他操作无法正常使用下的方法，当表过于复杂容易出错。</p>
  </li>
  <li>
    <p>使用 <code class="highlighter-rouge">distcp</code> 指令进行迁移</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c"># -skipcrccheck 规避跨Hadoop版本迁移的数据检验</span>
<span class="c"># hftp方式适用于跨集群迁移，hdfs适合集群内迁移</span>
<span class="nv">$ </span>hadoop distcp <span class="nt">-Dmapred</span>.job.name<span class="o">=</span>queueName <span class="nt">-update</span> <span class="nt">-skipcrccheck</span> hftp://domain:ip/user/sourceDestination user/targetDestination
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>如果迁移的是分区表，则需要预先用 <code class="highlighter-rouge">alter table</code> 指令造好分区文件夹，如果分区过多，则可以用 <code class="highlighter-rouge">distcp</code> 分批复制分区数据</p>
  </li>
</ul>

<h3 id="52-数据恢复">5.2 数据恢复</h3>

<p>首先要明白几点，被 <code class="highlighter-rouge">truncate</code> 的数据是无法恢复的，但是被 <code class="highlighter-rouge">drop</code> 或者 <code class="highlighter-rouge">insert overwrite</code> 的表第一时间是可以恢复的。</p>

<p>恢复的具体操作如下：</p>

<ul>
  <li>
    <p>建立一张相同格式的表 <code class="highlighter-rouge">newTable</code>， 存储格式和字段类型必须完全一致。</p>
  </li>
  <li>
    <p>从 <code class="highlighter-rouge">tmp</code> 目录中把数据复制出来：</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>hadoop fs <span class="nt">-cp</span> /tmp/username/stageing_hive_YYYY-MM-DD_id/<span class="k">*</span> path/databaseName.db/newTable/<span class="k">*</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h3 id="53-查询表更新情况">5.3 查询表更新情况</h3>

<ul>
  <li>
    <p>针对<strong>分区表</strong>可以直接查询最新分区来判断数据是否正确更新。</p>
  </li>
  <li>
    <p>针对<strong>无分区表</strong>，<code class="highlighter-rouge">desc formatted</code> 的结果往往不准确，所以要用Hadoop的指令去查询数据文件的更新时间。</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>hadoop fs <span class="nt">-ls</span> path/databaseName.db/tableName/
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>
:ET