I"<blockquote>
  <p>最近听说同学去面试被问了如何实现求根函数，想起来之前看过一篇帖子《<a href="https://blog.csdn.net/qq_26499321/article/details/73724763">sqrt函数实现(神奇的算法)</a>》，所以这里整理一下积累下来。</p>
</blockquote>

<h3 id="二分法">二分法</h3>

<p>常规思路就是二分法通过预设的精度无限逼近正确结果。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">sqrt_bisection</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'Input number should be non-negtive'</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">num</span>
    <span class="n">last_mid</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mid</span><span class="o">-</span><span class="n">last_mid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mid</span><span class="o">*</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">:</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="n">last_mid</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span> <span class="o">+</span> <span class="n">lower</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>        
    <span class="k">return</span> <span class="n">mid</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="牛顿迭代法">牛顿迭代法</h3>

<p>整体思路和二分法类似，也是通过迭代去逼近正确结果。首先代码如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">sqrt_newton</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'Input number should be non-negtive'</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">num</span>
    <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">res</span><span class="o">-</span><span class="n">last</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">):</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">res</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">num</span><span class="o">/</span><span class="n">res</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>至于原理，也很简单。就是用$(x, f(x))$的切线来逼近方程 $x^2 = a$ 的根。根号$a$实际上就是$x^2-a=0$的一个正实根，这个函数的导数是$2x$。也就是说，函数上任一点$(x,f(x))$处的切线斜率是$2x$。那么，$x-f(x)/(2x)$就是一个比$x$更接近的近似值。</p>

<h3 id="性能对比">性能对比</h3>

<p>这边测试一下性能，发现<strong>牛顿迭代法</strong>明显在迭代次数和计算时间上都会有很大的性能提升。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>sqrt_bisection: 18 loops
sqrt_bisection: 1.7430782318115234

sqrt_newton: 5 loops
sqrt_newton: 0.3349781036376953
</pre></td></tr></tbody></table></code></pre></div></div>

<p>事实上原文中还提供了第三种方法：</p>

<p>基于牛顿迭代的思路，通过一个预先设定的常数去做计算平方根。这然这样的方法相比前两种常规方法，时间极大地缩短了。但是这里我在从原文cpp转python的过程中发现同样的算法在python并没有奏效，可能是两种语言内部编译机制的问题，或者是我的理解的问题，在彻底弄清楚前就暂时先不放上来了。</p>
:ET